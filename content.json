{"meta":{"title":"Hexo","subtitle":"","description":"blog","author":"lzy","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-05-14T12:48:48.000Z","updated":"2024-05-14T14:58:40.081Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我印象最深刻的一句话是：有病就去治 请允许我载着理发店"}],"posts":[{"title":"hexo搭建教程","slug":"hexo","date":"2024-05-13T13:10:20.000Z","updated":"2024-05-14T18:49:29.884Z","comments":false,"path":"hexo/","permalink":"http://example.com/hexo/","excerpt":"","text":"1.环境准备1.1安装nodejsnodejs官网：https://nodejs.org/ 下载压缩包解压，并将解压的目录加入环境遍历即可 在命令行中输入node -v，出现以下输出表示安装成功 1.2安装git进入官网下载点击安装即可 1.安装hexo123456789#全局安装hexonpm install -g hexo-cli#初始化，blog为文件夹名hexo init blog#安装依赖cd blognpm install#启动服务器hexo server 2.修改主题官网主题：https://hexo.io/themes/ 推荐主题：volantis-x&#x2F;hexo-theme-volantis 123456#安装主题npm i hexo-theme-volantis#编辑_config.yml，修改themetheme: volantis#启动服务器hexo server 找到node_modules\\hexo-theme-volantis\\_config.yml 这是主题的配置文件，注释详细可自行修改，主要是对页面的修改 开启搜索功能 12345npm i -S hexo-generator-json-content#在_config.yml中加上search: enable: true service: hexo 3.部署到GitHub建立仓库，仓库名必须是 用户名.github.io，如543211494.github.io 修改_config.yml，加上以下信息: 1234deploy: type: git repo: https://github.com/543211494/543211494.github.io.git branch: main 执行以下命令 123456#安装hexo-deployer-gitnpm install hexo-deployer-git --save#生成静态文件hexo generate#上传到仓库hexo deploy 通过543211494.github.io即可访问","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"Netty学习笔记","slug":"netty-note","date":"2024-01-05T06:22:41.000Z","updated":"2024-05-14T16:01:38.397Z","comments":false,"path":"netty-note/","permalink":"http://example.com/netty-note/","excerpt":"","text":"1.I&#x2F;O模型java主要有3种网络编程模型：BIO、NIO、AIO BIO：同步并阻塞，服务器实现一个模式为一个连接一个线程。 NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接有I&#x2F;O请求就进行处理 AIO：异步非阻塞，引入异步通道的概念，采用了Proactor模式，有效的请求猜启动线程。 2.NIONIO有三大核心部分：Channel(通道)、Buffer(缓冲区)、Selector(选择器) 一个线程对应一个Selector，一个Selector对应多个Channel，每个Channel与客户之间有一个Buffer NIO与BIO比较： BIO以流的方式处理数据，NIO以块的方式处理数据，块I&#x2F;O的效率高 BIO是阻塞的，NIO是非阻塞的（通过Buffer实现） BIO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入通道，Selector用于监听多个通道的事件 2.1Channel通过channel读写文件 1234567891011121314151617181920212223242526272829package org.example;import java.io.*;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class Main &#123; public static void main( String[] args ) throws IOException &#123; String str = &quot;hello!&quot;; /* 创建输出流 */ FileOutputStream fileOutputStream = new FileOutputStream(&quot;test.txt&quot;); FileChannel fileChannel = fileOutputStream.getChannel(); /* 创建缓冲区 */ ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(str.getBytes()); /* 反转 */ byteBuffer.flip(); /* 将buffer的数据写入fileChannel */ fileChannel.write(byteBuffer); fileOutputStream.close(); /* 从文件中读取数据到buffer */ FileInputStream fileInputStream = new FileInputStream(new File(&quot;test.txt&quot;)); FileChannel fileChannel2 = fileInputStream.getChannel(); ByteBuffer byteBuffer2 = ByteBuffer.allocate(6); fileChannel2.read(byteBuffer2); System.out.println(new String(byteBuffer2.array())); fileInputStream.close(); &#125;&#125; 2.2Selector 当客户端连接时，会通过ServerSocketChannel得到SocketChannel 将SocketChannel注册到Selector上 注册后会返回一个SelectionKey，会和该Selector关联 Selector通过select方法进行监听，返回有事件发生的通道格式 Selector可以通过selectedKeys方法获取发送事件的通道对应的key集合 通过key获取channel及其buffer进行相关业务操作 服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.example;import java.io.*;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Set;public class NIOServer &#123; public static void main( String[] args ) throws IOException &#123; /* 创建ServerSocketChannel */ ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); /* 创建Selector */ Selector selector = Selector.open(); /* 绑定端口 */ serverSocketChannel.socket().bind(new InetSocketAddress(6666)); /* 设置为非阻塞 */ serverSocketChannel.configureBlocking(false); /* 把serverSocketChannel注册到selector,关心事件为OP_ACCEPT */ serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while(true)&#123; int result = selector.select(1000); System.out.println(result); if(result==0)&#123; System.out.println(&quot;服务器阻塞了1秒，无连接事件&quot;); &#125; if(result&gt;0)&#123; /* 返回一个包含当前已经就绪的SelectionKey集合的集合 */ Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator(); while(keyIterator.hasNext())&#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable())&#123; /* 有客户连接,为客户端生成一个socketChannel */ SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); /* 注册到selector，关注事件为OP_READ,同时关联一个Buffer */ socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(128)); &#125; if(key.isReadable())&#123; /* 通过key反向获取channel */ SocketChannel channel = (SocketChannel) key.channel(); /* 获取该channel关联的buffer */ ByteBuffer buffer = (ByteBuffer) key.attachment(); int bytesRead = channel.read(buffer); if (bytesRead == -1) &#123; /* 客户端关闭连接 */ channel.close(); key.cancel(); &#125; else if (bytesRead &gt; 0) &#123; System.out.println(&quot;Read:&quot;+new String(buffer.array())); /* 回复 */ buffer.flip(); channel.write(buffer); buffer.clear(); &#125; &#125; /* 移除当前key */ keyIterator.remove(); &#125; &#125; &#125; &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839package org.example;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;public class NIOClient &#123; public static void main( String[] args ) throws IOException &#123; /* 得到一个网络通道 */ SocketChannel socketChannel = SocketChannel.open(); /* 设置非阻塞 */ socketChannel.configureBlocking(false); /* 服务器端的ip和端口 */ InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;,6666); if(!socketChannel.connect(inetSocketAddress))&#123; while(!socketChannel.finishConnect())&#123; System.out.println(&quot;连接需要事件，客户端不会阻塞&quot;); &#125; &#125; String str = &quot;hello&quot;; ByteBuffer buffer = ByteBuffer.wrap(str.getBytes()); /* 发送数据，即将buffer数据写入channel中 */ socketChannel.write(buffer); ByteBuffer buffer1 = ByteBuffer.allocate(128); int bytesRead; bytesRead = socketChannel.read(buffer1); while (bytesRead != -1) &#123; System.out.println(bytesRead); /* -1表示连接断开，0表示暂时没有数据 */ if (bytesRead &gt; 0) &#123; System.out.println(new String(buffer1.array())); break; &#125; bytesRead = socketChannel.read(buffer1); &#125; socketChannel.close(); &#125;&#125; 3.NIO实现群聊服务端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package org.example.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Iterator;public class GroupChatServer &#123; private Selector selector; private ServerSocketChannel listener; private final static int PORT =6666; public GroupChatServer()&#123; try&#123; selector = Selector.open(); listener = ServerSocketChannel.open(); /* 绑定端口 */ listener.bind(new InetSocketAddress(PORT)); /* 设置为非阻塞 */ listener.configureBlocking(false); /* 注册到selector */ listener.register(selector, SelectionKey.OP_ACCEPT); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public void listen()&#123; try&#123; while (true)&#123; int count = this.selector.select(2000); if(count&gt;0)&#123; /* 返回一个包含当前已经就绪的SelectionKey集合的集合 */ Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; SelectionKey key = iterator.next(); /* 连接操作 */ if(key.isAcceptable())&#123; SocketChannel channel = listener.accept(); /* 设置为非阻塞 */ channel.configureBlocking(false); /* 注册到selector */ channel.register(this.selector,SelectionKey.OP_READ); System.out.println(channel.getRemoteAddress()+&quot;上线了&quot;); &#125; if(key.isReadable())&#123; this.readData(key); &#125; /* 删除，防止重复操作 */ iterator.remove(); &#125; &#125; &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 读取客户端消息 * @param key */ public void readData(SelectionKey key)&#123; SocketChannel channel = null; try&#123; channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); /* count为读取的字节数 */ int count = channel.read(buffer); if(count&gt;0)&#123; String message = new String(buffer.array()).trim(); System.out.println(&quot;客户端消息:&quot;+message); /* 向其他客户端发送消息 */ this.sendToOther(message,channel); &#125; &#125;catch (IOException e)&#123; try&#123; System.out.println(channel.getRemoteAddress()+&quot;下线了&quot;); /* 客户端关闭连接 */ key.cancel(); channel.close(); &#125;catch (IOException error)&#123; error.printStackTrace(); &#125; &#125; &#125; /** * 向其他节点广播消息 * @param message 消息 * @param self 消息发送者 */ private void sendToOther(String message,SocketChannel self)&#123; ByteBuffer buffer = ByteBuffer.wrap(message.getBytes()); /* 通过key遍历所有的channel */ for(SelectionKey key:this.selector.keys())&#123; Channel channel = key.channel(); if(channel instanceof SocketChannel &amp;&amp; !channel.equals(self))&#123; SocketChannel target = (SocketChannel) channel; try&#123; target.write(buffer); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; /* 重置buffer */ buffer.flip(); &#125; &#125; &#125; public static void main( String[] args)&#123; GroupChatServer server = new GroupChatServer(); server.listen(); &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package org.example.groupchat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class GroupChatClient &#123; private final static String HOST = &quot;127.0.0.1&quot;; private final static int PORT = 6666; private Selector selector; private SocketChannel channel; private String username; public GroupChatClient()&#123; try&#123; selector = Selector.open(); /* 连接到服务器 */ channel = SocketChannel.open(new InetSocketAddress(HOST,PORT)); /* 设置为非阻塞 */ channel.configureBlocking(false); /* 注册到selector */ channel.register(this.selector,SelectionKey.OP_READ); /* 获得username */ username = channel.getLocalAddress().toString().substring(1); System.out.println(username+&quot;is ok!&quot;); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 向服务器发送消息 * @param message */ public void sendToServer(String message)&#123; String info = this.username+&quot;:&quot;+message; ByteBuffer buffer = ByteBuffer.wrap(info.getBytes()); try&#123; this.channel.write(buffer); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; /** * 接受服务端消息 */ public void readInfo()&#123; try&#123; int count = this.selector.select(); if(count&gt;0)&#123; Iterator&lt;SelectionKey&gt; iterator = this.selector.selectedKeys().iterator(); while(iterator.hasNext())&#123; SelectionKey key = iterator.next(); if(key.isReadable())&#123; SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); /* 将channel中的数据读入buffer中 */ sc.read(buffer); System.out.println(new String(buffer.array()).trim()); &#125; &#125; iterator.remove(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; final GroupChatClient chatClient = new GroupChatClient(); /* 启动一个线程 */ new Thread()&#123; public void run()&#123; while(true)&#123; chatClient.readInfo(); &#125; &#125; &#125;.start(); /* 发送消息 */ Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine())&#123; chatClient.sendToServer(scanner.nextLine()); &#125; &#125;&#125; 4.零拷贝一种高效的数据传输技术，它可以将数据从内核空间直接传输到应用程序的内存空间中。 传统的数据传输过程通常需要经历多次内存拷贝。 首先，从磁盘读取数据，然后将数据从内核空间拷贝到用户空间，再从用户空间拷贝到应用程序的内存中。这些额外的拷贝会消耗大量的CPU资源和内存带宽，降低数据传输的效率。 零拷贝就是为了避免这些不必要的数据拷贝，能够将数据直接传输到目标内存区域，以提高数据传输的效率。 使用方法： 123FileChannel fileChannel = new FileInputStream(filename).getChannel();long transferCount = fileChannel.transferTo(0,fileChannel.size(),socketChannel);fileChannel.close(); 5.Netty官网：https://netty.io/ 5.1线程模型目前的线程模式有：传统阻塞I&#x2F;O服务模型、Reactor模型 Reactor模型： 基于I&#x2F;O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需等待所有连接 基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务 根据Reator的数量和处理资源线程池的数量不太，有3种实现： 单Reactor单线程：接收客户端请求和处理请求都在主线程中 单Reactor多线程：在主线程中接受客户端请求和响应事件，通过worker线程池分配独立线程完成真正的业务 主从Reactor多线程：主Reactor只负责建立连接，I&#x2F;O读取给子Reactor，真正的业务处理通过worker线程池分配独立线程完成 5.2Netty模型 Netty抽象出两组线程池，BossGroup专门负责接受客户端的连接，WorkGroup专门负责网络的读写，类型都是NioEventLoopGroup NioEventLoopGroup相当于一个事件循环组，每个组中都含有多个事件循环，每个事件循环都是NioEventLoop NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket的网络通讯 每个Boss NioEventLoop执行的步骤有3步：(1)轮询accept事件、(2)处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NIOEventLoop上的selector、(3)处理任务队列的任务，即runAllTasks 每个Worker NIOEventLoop循环执行的步骤(1)轮询read&#x2F;write事件、(2)处理I&#x2F;O事件，即read&#x2F;write任务、(3)处理任务队列的任务，即runAllTasks 每个Worker NIOEventLoop处理业务时会使用pipeline，pipeline中包含了channel，即通过pipeline可以获取到对应通道 5.3Netty示例（TCP）引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt; 服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.example.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; /** * 创建BossGroup和WorkerGroup * BossGroup只处理连接请求，真正业务处理由WorkerGroup完成 * 两个都是无限循环 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); /* 创建服务器端的启动对象，配置参数 */ ServerBootstrap bootstrap = new ServerBootstrap(); try&#123; /* 设置参数 */ bootstrap.group(bossGroup,workerGroup)//设置两个线程组 .channel(NioServerSocketChannel.class)//使用NioSocketChannel作为服务器的通道实现 .option(ChannelOption.SO_BACKLOG,128)//设置线程队列得到连接个数 .childOption(ChannelOption.SO_KEEPALIVE,true)//设置保持活动连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; /* 给pipeline设置处理器 */ @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); System.out.println(&quot;......服务器 is ready...&quot;); /* 绑定一个端口并且同步，生成一个ChannelFuture对象 */ ChannelFuture channelFuture = bootstrap.bind(6668).sync(); /* 对关闭通道进行监听 */ channelFuture.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 服务端Handler 1234567891011121314151617181920212223242526272829303132333435363738394041package org.example.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;/** * 自定义一个Handler，需要继承netty规定好的某个HandlerAdapter */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; /** * * @param ctx 上下文对象，含有管道pipeline，通道channel,地址 * @param msg 客户端发送的数据，默认为Object * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(&quot;sercer ctx = &quot;+ctx); ByteBuf buffer = (ByteBuf) msg; System.out.println(&quot;客户端发送的消息是：&quot;+buffer.toString(CharsetUtil.UTF_8)); System.out.println(&quot;客户端地址：&quot;+ ctx.channel().remoteAddress()); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; /* 写入缓冲区并刷新 */ ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,客户端&quot;, CharsetUtil.UTF_8)); &#125; /** * 处理异常 */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637package org.example.netty.simple;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; /* 客户端需要一个事件循环组 */ EventLoopGroup eventExecutors = new NioEventLoopGroup(); /* 创建客户端启动对象 */ Bootstrap bootstrap = new Bootstrap(); try&#123; /* 设置相关参数 */ bootstrap.group(eventExecutors)//设置线程组 .channel(NioSocketChannel.class)//设置客户端通道的实现类(用于反射) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; /* 加入自己的处理器 */ socketChannel.pipeline().addLast(new NettyClientHandler()); &#125; &#125;); System.out.println(&quot;客户端 ok...&quot;); /* 启动客户端去连接服务器 */ ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;,6668).sync(); /* 给关闭通道进行监听 */ channelFuture.channel().closeFuture().sync(); &#125;finally &#123; eventExecutors.shutdownGracefully(); &#125; &#125;&#125; 客户端Handler 12345678910111213141516171819202122232425262728293031323334353637package org.example.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; /** * 通道就绪就会触发 */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;client&quot;+ctx); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,server&quot;, CharsetUtil.UTF_8)); &#125; /** * 当通道有读取事件时触发 */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buffer = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息：&quot;+buffer.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器地址：&quot;+ctx.channel().remoteAddress()); &#125; /** * 处理异常 */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125; 5.4TaskQueueNioEventLoop中除了Selector还有一个TaskQueue。Handler中耗时任务可提交值TaskQueue异步执行。 提交普通任务(提交多个任务依次执行) 1234567891011121314151617@Overridepublic void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception &#123; /* 解决方案1用户自定义普通任务 */ final ChannelHandlerContext context = ctx; ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try&#123; Thread.sleep(10000); context.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,客户端1&quot;, CharsetUtil.UTF_8)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 提交自定义定时任务 1234567891011121314151617@Overridepublic void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception &#123; /* 解决方案2用户自定义定时任务 */ final ChannelHandlerContext context = ctx; ctx.channel().eventLoop().schedule(new Runnable() &#123; @Override public void run() &#123; try&#123; Thread.sleep(10000); context.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,客户端1&quot;, CharsetUtil.UTF_8)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;,5, TimeUnit.SECONDS);&#125; 5.5Future异步：当一个异步过程调用发出后，调用者不能立刻得到结果，等调用完成后通过状态、通知和回调来通知调用者 Netty的异步模型是建立在future和callback之上的 ChannelFuture是一个接口，可以添加监听器，当监听的事件发生时，就会通知监听器 当Future对象刚刚创建时处于非完成状态，调用者可用通过返回的ChannelFuture来获取操作执行状态，注册监听函数执行完成后的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.example.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; /** * 创建BossGroup和WorkerGroup * BossGroup只处理连接请求，真正业务处理由WorkerGroup完成 * 两个都是无限循环 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); /* 创建服务器端的启动对象，配置参数 */ ServerBootstrap bootstrap = new ServerBootstrap(); try&#123; /* 设置参数 */ bootstrap.group(bossGroup,workerGroup)//设置两个线程组 .channel(NioServerSocketChannel.class)//使用NioSocketChannel作为服务器的通道实现 .option(ChannelOption.SO_BACKLOG,128)//设置线程队列得到连接个数 .childOption(ChannelOption.SO_KEEPALIVE,true)//设置保持活动连接状态 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; /* 给pipeline设置处理器 */ @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); System.out.println(&quot;......服务器 is ready...&quot;); /* 绑定一个端口并且同步，生成一个ChannelFuture对象 */ ChannelFuture channelFuture = bootstrap.bind(6668).sync(); channelFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if(channelFuture.isSuccess())&#123; System.out.println(&quot;监听端口6668成功&quot;); &#125; &#125; &#125;); /* 对关闭通道进行监听 */ channelFuture.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 5.6Netty示例（HTTP）HttpServer 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.example.netty.http;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class HttpServer &#123; public static void main(String[] args)&#123; /** * 创建BossGroup和WorkerGroup,1代表指定的线程数 * BossGroup只处理连接请求，真正业务处理由WorkerGroup完成 * 两个都是无限循环 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; /* 创建服务器端的启动对象，配置参数 */ ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new HttpServerInitializer()); ChannelFuture channelFuture = bootstrap.bind(8080).sync(); channelFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if(channelFuture.isSuccess())&#123; System.out.println(&quot;监听端口6668成功&quot;); &#125; &#125; &#125;); /* 对关闭通道进行监听 */ channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; HttpServerHandler 12345678910111213141516171819202122232425262728293031package org.example.netty.http;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.util.CharsetUtil;public class HttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; /** * 有读取事件时会触发这个函数 * @param channelHandlerContext 上下文 * @param httpObject 消息 * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, HttpObject httpObject) throws Exception &#123; if(httpObject instanceof HttpRequest)&#123; System.out.println(&quot;客户端地址：&quot;+channelHandlerContext.channel().remoteAddress()); ByteBuf buffer = Unpooled.copiedBuffer(&quot;hello&quot;, CharsetUtil.UTF_8); /* 构造一个httpresponse */ FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer); response.headers().set(HttpHeaderNames.CONTENT_TYPE,&quot;text/plain&quot;); response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes()); /* 将构建好的HttpResponse */ channelHandlerContext.writeAndFlush(response); &#125; &#125;&#125; HttpServerInitializer 123456789101112131415161718package org.example.netty.http;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.http.HttpServerCodec;public class HttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; /* 得到管道 */ ChannelPipeline pipeline = socketChannel.pipeline(); /* 加入一个netty提供的编/解码器 */ pipeline.addLast(&quot;myHttpServerCodec&quot;,new HttpServerCodec()); /* 增加一个自定义的handler */ pipeline.addLast(&quot;myHttpHandler&quot;,new HttpServerHandler()); &#125;&#125; 5.7Unpooled类专门操作缓冲区的工具类 12345678910111213141516171819202122package org.example.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.util.CharsetUtil;public class Main &#123; public static void main(String[] args)&#123; ByteBuf buffer = Unpooled.buffer(10); for(int i = 0;i&lt;10;i++)&#123; buffer.writeByte(i); &#125; for(int i = 0;i&lt;10;i++)&#123; System.out.println(buffer.readByte()); &#125; ByteBuf buffer1 = Unpooled.copiedBuffer(&quot;hello,你好&quot;, CharsetUtil.UTF_8); if(buffer1.hasArray())&#123; byte[] content = buffer1.array(); System.out.println(new String(content,CharsetUtil.UTF_8).trim()); &#125; &#125;&#125; 5.8Netty群聊示例GroupChatServer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.example.netty.groupchat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class GroupChatServer &#123; /** * 监听端口 */ private int port; public GroupChatServer(int port) &#123; this.port = port; &#125; public void run() throws InterruptedException &#123; /* 创建两个线程组 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG,128) .childOption(ChannelOption.SO_KEEPALIVE,true) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(&quot;decoder&quot;,new StringDecoder()); pipeline.addLast(&quot;encoder&quot;,new StringEncoder()); pipeline.addLast(new GroupChatServerHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(this.port).sync(); channelFuture.channel().closeFuture().sync(); System.out.println(&quot;netty 服务器启动！&quot;); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args)&#123; try &#123; new GroupChatServer(6668).run(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; GroupChatServerHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package org.example.netty.groupchat;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.util.concurrent.GlobalEventExecutor;import java.text.SimpleDateFormat;public class GroupChatServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; /** * 定义一个channel组，管理全局的channel * GlobalEventExecutor.INSTANCE是一个全局事件执行器，是一个单例 */ private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); /** * 建立连接后执行该函数 * @param context 上下文 */ @Override public void handlerAdded(ChannelHandlerContext context)&#123; Channel channel = context.channel(); /* 广播该客户加入的消息 */ channelGroup.add(channel); channelGroup.writeAndFlush(&quot;[客户端]：&quot;+channel.remoteAddress()+&quot;加入聊天！&quot;); &#125; /** * 连接断开 * @param context * @throws Exception */ @Override public void handlerRemoved(ChannelHandlerContext context) throws Exception &#123; Channel channel = context.channel(); channelGroup.writeAndFlush(&quot;[客户端]：&quot;+channel.remoteAddress()+&quot;离开聊天！&quot;); /* ChannelGroup会自动remove该channel */ &#125; /** * 表示channel处于活跃状态 * @param context * @throws Exception */ @Override public void channelActive(ChannelHandlerContext context) throws Exception &#123; System.out.println(context.channel().remoteAddress()+&quot;上线！&quot;); &#125; /** * 表示channel处于非活跃状态 * @param context * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext context) throws Exception &#123; System.out.println(context.channel().remoteAddress()+&quot;下线！&quot;); &#125; /** * 发生读事件时调用 * @param context * @param message * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext context, String message) throws Exception &#123; Channel channel = context.channel(); /* 广播消息 */ for(Channel ch:channelGroup)&#123; if(!ch.equals(channel))&#123; ch.writeAndFlush(&quot;[客户端]&quot;+ch.remoteAddress()+&quot;:&quot;+message); &#125;else&#123; ch.writeAndFlush(&quot;[自己]:&quot;+message); &#125; &#125; &#125; /** * 发生异常 * @param context * @param cause * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) throws Exception &#123; /* 关闭通道 */ context.close(); &#125;&#125; GroupChatClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.example.netty.groupchat;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.util.Scanner;public class GroupChatClient &#123; private String host; private int port; public GroupChatClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public void run() throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap bootstrap = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(&quot;decoder&quot;,new StringDecoder()); pipeline.addLast(&quot;encoder&quot;,new StringEncoder()); pipeline.addLast(new GroupChatClientHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(this.host, this.port).sync(); Channel channel = channelFuture.channel(); Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine())&#123; String message = scanner.nextLine(); channel.writeAndFlush(message); &#125; channel.closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args)&#123; try &#123; new GroupChatClient(&quot;127.0.0.1&quot;,6668).run(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; GroupChatClientHandler 1234567891011121314151617package org.example.netty.groupchat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class GroupChatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; /** * 发生读事件时调用 * @param context * @param message * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext context, String message) throws Exception &#123; System.out.println(message.trim()); &#125;&#125; 5.9心跳机制加入一个netty提供的IdleStateHandler(空闲状态处理器)实现心跳检测，当IdleStateHandler触发后会会传递给管道的下一个Handler去处理，通过调用下一个Handler的userTriggered方法，在该方法中处理 MyServer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package org.example.netty.heartbeat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;public class MyServer &#123; public static void main(String[] args)&#123; /* 创建两个线程组 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO))//在bootstrap添加一个日志处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /** * 加入一个netty提供的IdleStateHandler(空闲状态处理器) * readerIdleTime:表示多长时间没有读操作就会发送一个心跳检测包检测是否还是连接状态 * writerIdleTime:表示多长时间没有写操作就会发送一个心跳检测包检测是否还是连接状态 * allIdleTime:表示多长时间没有读/写操作就会发送一个心跳检测包检测是否还是连接状态 * 当IdleStateHandler触发后会会传递给管道的下一个Handler去处理， * 通过调用下一个Handler的userTriggered,在该方法中处理 */ pipeline.addLast(new IdleStateHandler(3,5,7, TimeUnit.SECONDS)); pipeline.addLast(new MyServerHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(6668).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyServerHandler 123456789101112131415161718192021222324252627282930package org.example.netty.heartbeat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.handler.timeout.IdleState;import io.netty.handler.timeout.IdleStateEvent;public class MyServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if(evt instanceof IdleStateEvent)&#123; IdleStateEvent event = (IdleStateEvent) evt; String eventType = null; switch (event.state())&#123; case READER_IDLE: eventType=&quot;读空闲&quot;; break; case WRITER_IDLE: eventType=&quot;写空闲&quot;; break; case ALL_IDLE: eventType=&quot;读写空闲&quot;; break; &#125; System.out.println(ctx.channel().remoteAddress()+&quot;--超时事件--&quot;+eventType); &#125; &#125;&#125; 5.10WebSocket示例前端页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var socket; //判断当前浏览器是否支持websocket if(window.WebSocket) &#123; //go on socket = new WebSocket(&quot;ws://localhost:8001/hello&quot;); //相当于channelReado, ev 收到服务器端回送的消息 socket.onmessage = function (ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; + ev.data; &#125; //相当于连接开启(感知到连接开启) socket.onopen = function (ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = &quot;连接开启了..&quot; &#125; //相当于连接关闭(感知到连接关闭) socket.onclose = function (ev) &#123; var rt = document.getElementById(&quot;responseText&quot;); rt.value = rt.value + &quot;\\n&quot; + &quot;连接关闭了..&quot; &#125; &#125; else &#123; alert(&quot;当前浏览器不支持websocket&quot;) &#125; //发送消息到服务器 function send(message) &#123; if(!window.socket) &#123; //先判断socket是否创建好 return; &#125; if(socket.readyState == WebSocket.OPEN) &#123; //通过socket 发送消息 socket.send(message) &#125; else &#123; alert(&quot;连接没有开启&quot;); &#125; &#125;&lt;/script&gt; &lt;form onsubmit=&quot;return false&quot;&gt; &lt;textarea name=&quot;message&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;发生消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt; &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;button&quot; value=&quot;清空内容&quot; onclick=&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; MyServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.example.netty.websocket;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;import io.netty.handler.timeout.IdleStateHandler;import org.example.netty.heartbeat.MyServerHandler;import java.util.concurrent.TimeUnit;public class MyServer &#123; public static void main(String[] args)&#123; /* 创建两个线程组 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO))//在bootstrap添加一个日志处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); //因为基于http协议，使用http的编码和解码器 pipeline.addLast(new HttpServerCodec()); //http是以块方式写，添加ChunkedWriteHandler处理器 pipeline.addLast(new ChunkedWriteHandler()); /** * http数据在传输时是分段的 * HttpObjectAggregator可以将多个段聚合 */ pipeline.addLast(new HttpObjectAggregator(8192)); /** * websocket的数据以帧(frame)的形式传输 * 浏览器请求时以ws://127.0.0.1:8000/hello表示请求的url * WebSocketServerProtocolHandler将http协议升级为ws协议，保持长连接 */ pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/hello&quot;)); /* 自定义的handler ，处理业务逻辑 */ pipeline.addLast(new MyTextWebSocketFrameHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(8001).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; MyTextWebSocketFrameHandler 123456789101112131415161718192021222324252627282930313233343536373839404142package org.example.netty.websocket;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import java.time.LocalDateTime;/** * 这里 TextWebSocketFrame 类型，表示一个文本帧(frame) */public class MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; /** * 当Web客户端连接后触发 * @param ctx * @throws Exception */ @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asLongText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;handlerRemoved 被调用&quot; + ctx.channel().id().asLongText()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(&quot;异常发生 &quot; + cause.getMessage()); ctx.close(); //关闭连接 &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, TextWebSocketFrame textWebSocketFrame) throws Exception &#123; System.out.println(&quot;服务器收到消息 &quot; + textWebSocketFrame.text()); Channel channel = channelHandlerContext.channel(); channel.writeAndFlush(new TextWebSocketFrame(&quot;服务器时间&quot;+ LocalDateTime.now()+&quot;:&quot;+textWebSocketFrame.text())); &#125;&#125; 5.11出站入站出站：发送消息 入站：收到消息 以入站为例，对于每个从入站 Channel 读取的消息，这个方法会被调用（解码）。随后，它将调用由解码器所提供的 decode()方法进行解码，并将已经解码的字节转发给 ChannelPipeline中的下一个 ChannelInboundHandler。byteBuf中有可读字节就会调用decoder，list中有对象就会调用下一个 ChannelInboundHandler。 handler调用机制示例 客户端： 1234567891011121314151617181920212223242526272829303132333435363738package org.example.netty.handler;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class MyClient &#123; public static void main(String[] args)&#123; EventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* 编码器 */ pipeline.addLast(new MyLongToByteEncoder()); /* 解码器 */ pipeline.addLast(new MyByteToLongDecoder()); pipeline.addLast(new MyClientHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8001).sync(); Channel channel = channelFuture.channel(); channel.closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 123456789101112131415161718package org.example.netty.handler;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, Long message) throws Exception &#123; System.out.println(&quot;\\n收到服务端回复：&quot;+message); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;\\nchannelActive被调用&quot;); ctx.writeAndFlush(123456L); &#125;&#125; 服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.example.netty.handler;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class MyServer &#123; public static void main(String[] args)&#123; /* 创建两个线程组 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* 解码器 */ pipeline.addLast(new MyByteToLongDecoder()); /* 编码器 */ pipeline.addLast(new MyLongToByteEncoder()); pipeline.addLast(new MyServerHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(8001).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 12345678910111213141516171819package org.example.netty.handler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class MyServerHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, Long message) throws Exception &#123; System.out.println(&quot;\\nchannelRead0被调用&quot;); System.out.println(&quot;从客户端：&quot;+channelHandlerContext.channel().remoteAddress()+&quot;读取到：&quot;+message); channelHandlerContext.writeAndFlush(message); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); ctx.close(); &#125;&#125; 编码器： 1234567891011121314package org.example.netty.handler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class MyLongToByteEncoder extends MessageToByteEncoder&lt;Long&gt; &#123; @Override protected void encode(ChannelHandlerContext channelHandlerContext, Long message, ByteBuf byteBuf) throws Exception &#123; System.out.println(&quot;\\nencoder被调用&quot;); System.out.println(&quot;message:&quot;+message); byteBuf.writeLong(message); &#125;&#125; 解码器： 1234567891011121314151617181920212223242526package org.example.netty.handler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import java.util.List;public class MyByteToLongDecoder extends ByteToMessageDecoder &#123; /** * * @param channelHandlerContext 上下文 * @param byteBuf 入站的buffer * @param list 传给下一个handler处理的对象集合 * @throws Exception */ @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; System.out.println(&quot;\\ndecoder被调用&quot;); /* Long有8个字节，大于8才能读取 */ if(byteBuf.readableBytes()&gt;=8)&#123; list.add(byteBuf.readLong()); &#125; &#125;&#125; 5.12解决TCP粘包拆包通常使用自定义协议+编解码器解决 服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.example.netty.procotoltcp;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class MyServer &#123; public static void main(String[] args)&#123; /* 创建两个线程组 */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try&#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* 加入编码器 */ pipeline.addLast(new MyMessageEncoder()); /* 加入解码器 */ pipeline.addLast(new MyMessageDecoder()); pipeline.addLast(new MyServerHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind(8001).sync(); channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930package org.example.netty.procotoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;import java.nio.charset.StandardCharsets;import java.util.UUID;public class MyServerHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol) throws Exception &#123; System.out.println(&quot;\\n服务端收到消息&quot;); System.out.println(&quot;长度：&quot;+messageProtocol.getLength()); System.out.println(&quot;内容：&quot;+new String(messageProtocol.getContent(),CharsetUtil.UTF_8)); String response = UUID.randomUUID().toString(); byte[] content = response.getBytes(StandardCharsets.UTF_8); channelHandlerContext.writeAndFlush(new MessageProtocol(content.length,content)); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839package org.example.netty.procotoltcp;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class MyClient &#123; public static void main(String[] args)&#123; EventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* 加入编码器 */ pipeline.addLast(new MyMessageEncoder()); /* 加入解码器 */ pipeline.addLast(new MyMessageDecoder()); pipeline.addLast(new MyClientHandler()); &#125; &#125;); ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8001).sync(); Channel channel = channelFuture.channel(); channel.closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package org.example.netty.procotoltcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.util.CharsetUtil;public class MyClientHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol) throws Exception &#123; System.out.println(&quot;\\n客户端收到消息&quot;); System.out.println(&quot;长度：&quot;+messageProtocol.getLength()); System.out.println(&quot;内容：&quot;+new String(messageProtocol.getContent(),CharsetUtil.UTF_8)); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for(int i = 0;i&lt;5;i++)&#123; byte[] content = (&quot;hello,server&quot; + i).getBytes(CharsetUtil.UTF_8); int length = content.length; MessageProtocol messageProtocol = new MessageProtocol(content.length,content); ctx.writeAndFlush(messageProtocol); &#125; &#125;&#125; 解码器 12345678910111213141516171819package org.example.netty.procotoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import java.util.List;public class MyMessageDecoder extends ByteToMessageDecoder &#123; @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; System.out.println(&quot;\\ndecoder被调用&quot;); int length = byteBuf.readInt(); byte[] content = new byte[length]; byteBuf.readBytes(content); MessageProtocol message = new MessageProtocol(length, content); list.add(message); &#125;&#125; 编码器 1234567891011121314package org.example.netty.procotoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class MyMessageEncoder extends MessageToByteEncoder&lt;MessageProtocol&gt;&#123; @Override protected void encode(ChannelHandlerContext channelHandlerContext, MessageProtocol messageProtocol, ByteBuf byteBuf) throws Exception &#123; System.out.println(&quot;\\nencoder被调用&quot;); byteBuf.writeInt(messageProtocol.getLength()); byteBuf.writeBytes(messageProtocol.getContent()); &#125;&#125; 消息类 1234567891011121314151617181920212223242526272829package org.example.netty.procotoltcp;public class MessageProtocol &#123; private int length; private byte[] content; public MessageProtocol(int length, byte[] content) &#123; this.length = length; this.content = content; &#125; public int getLength() &#123; return length; &#125; public void setLength(int length) &#123; this.length = length; &#125; public byte[] getContent() &#123; return content; &#125; public void setContent(byte[] content) &#123; this.content = content; &#125;&#125; 5.13实现简易RPC在Netty中，通常一个连接（如TCP连接）会对应一个Channel，而每个Channel都有一个ChannelPipeline，而ChannelPipeline中包含了一个或多个ChannelHandler。@Sharable可让Handler被多个连接共用 接口： 12345package org.example.netty.rpc;public interface HelloService &#123; String hello(String mes);&#125; 接口实现类 123456789package org.example.netty.rpc;public class HelloServiceImpl implements HelloService&#123; @Override public String hello(String mes) &#123; System.out.println(&quot;收到客户端消息=&quot; + mes); return &quot;收到消息=&quot; + mes; &#125;&#125; NettyClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package org.example.netty.rpc;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.lang.reflect.Proxy;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NettyClient &#123; //创建线程池 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static NettyClientHandler client; //这里定义协议头 public static final String providerName = &quot;HelloService#hello#&quot;; private int count = 0; //编写方法使用代理模式，获取一个代理对象 public Object getBean(final Class&lt;?&gt; serivceClass, final String providerName) &#123; /** * 第一个参数Thread.currentThread().getContextClassLoader()是类加载器，用于加载动态代理类 * 第二个参数new Class&lt;?&gt;[]&#123;serivceClass&#125;是接口数组，指定了代理类要实现的接口 * 第三个参数是一个InvocationHandler接口的实现，它定义了代理类的调用处理程序，即当代理对象调用方法时，会被转发到这个处理程序中进行处理。 */ return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123; System.out.println(&quot;(proxy, method, args) 进入....&quot; + (++count) + &quot; 次&quot;); //&#123;&#125; 部分的代码，客户端每调用一次 hello, 就会进入到该代码 if (client == null) &#123; initClient(); &#125; //设置要发给服务器端的信息 //providerName 协议头 args[0] 就是客户端调用api hello(???), 参数 client.setPara(providerName + args[0]); /** * executor.submit(client)将 client 对象提交给线程池executor进行执行 * executor.submit()方法接受一个Runnable或Callable对象 * 并返回一个Future对象，用于表示异步任务的结果。 */ return executor.submit(client).get(); &#125;); &#125; //初始化客户端 private static void initClient() &#123; client = new NettyClientHandler(); //创建EventLoopGroup NioEventLoopGroup group = new NioEventLoopGroup(); Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler( new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); pipeline.addLast(client); &#125; &#125; ); try &#123; // 和服务端建立连接 bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; //创建一个消费者 NettyClient customer = new NettyClient(); //创建代理对象 HelloService service = (HelloService) customer.getBean(HelloService.class,providerName); for (; ; ) &#123; Thread.sleep(2 * 1000); //通过代理对象调用服务提供者的方法(服务) String res = service.hello(&quot;你好 dubbo~&quot;); System.out.println(&quot;调用的结果 res= &quot; + res); &#125; &#125;&#125; NettyClientHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.example.netty.rpc;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import java.util.concurrent.Callable;public class NettyClientHandler extends ChannelInboundHandlerAdapter implements Callable &#123; private ChannelHandlerContext context;//上下文 private String result; //返回的结果 private String para; //客户端调用方法时，传入的参数 //与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1) @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot; channelActive 被调用 &quot;); context = ctx; //因为我们在其它方法会使用到 ctx &#125; //收到服务器的数据后，调用方法 (4) // @Override public synchronized void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(&quot; channelRead 被调用 &quot;); result = msg.toString(); notify(); //唤醒等待的线程 &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125; //被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5 @Override public synchronized Object call() throws Exception &#123; System.out.println(&quot; call1 被调用 &quot;); context.writeAndFlush(para); //进行wait wait(); //等待channelRead 方法获取到服务器的结果后，唤醒 System.out.println(&quot; call2 被调用 &quot;); return result; //服务方返回的结果 &#125; //(2) void setPara(String para) &#123; System.out.println(&quot; setPara &quot;); this.para = para; &#125;&#125; NettyServer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.example.netty.rpc;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class NettyServer &#123; // 静态方法:启动服务端 public static void startServer(String hostName, int port) &#123; startServer0(hostName, port); &#125; //编写一个方法，完成对NettyServer的初始化和启动 private static void startServer0(String hostname, int port) &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); //自定义的业务处理器，我们即通过该处理器实现我们自定义的业务需求 pipeline.addLast(new NettyServerHandler()); &#125; &#125; ); ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync(); System.out.println(&quot;服务提供方开始提供服务~~&quot;); channelFuture.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; NettyServer.startServer(&quot;127.0.0.1&quot;, 7000); &#125;&#125; NettyServerHandler 1234567891011121314151617181920212223package org.example.netty.rpc;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //获取客户端发送的消息，并调用服务 System.out.println(&quot;msg=&quot; + msg); //客户端在调用服务器的api 时，我们需要定义一个协议 //比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot; if (msg.toString().startsWith(NettyClient.providerName)) &#123; String result = new HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(&quot;#&quot;) + 1)); ctx.writeAndFlush(result); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125;","categories":[{"name":"Netty","slug":"Netty","permalink":"http://example.com/categories/Netty/"}],"tags":[]},{"title":"matlab代码导出为jar包方法","slug":"matlab2jar","date":"2023-11-04T13:33:23.000Z","updated":"2024-05-14T16:24:27.859Z","comments":false,"path":"matlab2jar/","permalink":"http://example.com/matlab2jar/","excerpt":"","text":"1.导出JAR包方法java版本不得高于8 以func.m为例 123function result = func(x) result = 2*x+1;end 在命令行窗口输入deploytool,如下图 选择Library Complier,选择Java Package和matlab文件,设置类名并打包 打包会生成四个文件夹 所需要的jar包在for_redistribution_files_only中,如下图 2.Java调用matlab导出的JAR包运行jar包还需要matlab中的javabuilder.jar文件,具体位置如下图所示 将javabuilder.jar和导出的jar包导入java工程项目 调用jar包 可以看到这里对导出的Func生成了三个同名方法,其中最常用的是第三个方法 其第一个参数代表传入参数的个数 其后是可变参数,即传入的x 其对应的matlab代码为: 123function result = func(x) result = 2*x+1;end 其余参数含义可自行查询 这里展示了调用matlab实现的计算2*x+1的函数和绘制sigmod图像的函数的具体过程 3.Ubuntu下搭建matlab运行时环境Windows环境下导出的jar包直接在Ubuntu下运行会出现缺少动态库等异常，如下图 因此需要配置matlab运行时环境 matlab运行时环境下载：https://www.mathworks.com/products/compiler/matlab-runtime.html 安装方法： 12345678910111213#解压文件unzip MATLAB_Runtime_R2022b_glnxa64.zip#交互式安装（图形界面）sudo -H ./install#非交互式安装（命令行）./install -inputfile installer_input.txt#installer_input.txt文件内容为：#agreeToLicense=yes#destinationFolder=/usr/MATLAB/MATLAB_Runtime#outputFile=myapp_log.txt#-agreeToLicense：同意 MATLAB Runtime 许可证。#-destinationFolder：指定 MATLAB Runtime 的安装位置。#-outputFile：指定安装日志文件的写入位置。 或者将以前安装过的环境文件夹直接拷贝过来也行 安装完成后，添加环境变量sudo vim /etc/profile ，并重启 1export LD_LIBRARY_PATH=/home/lzy/Downloads/matlab/R2022b/runtime/glnxa64 Ubuntu下java调matlab导出的jar包与matlab代码运行对比如下：","categories":[{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/categories/Matlab/"}],"tags":[]},{"title":"Vue3学习笔记","slug":"Vue3-note","date":"2023-09-09T16:38:20.000Z","updated":"2024-05-14T14:40:48.221Z","comments":false,"path":"Vue3-note/","permalink":"http://example.com/Vue3-note/","excerpt":"","text":"1.构建项目1.1使用vue-cli创建Vue3项目123456#安装vue-clinpm install -g @vue/cli#查看版本vue -V#创建项目vue create &lt;project_name&gt; 1.2使用vite创建Vue3项目12345678910#全局安装#npm install -g create-vite-app@1.21.0#创建工程npm init vite-app &lt;project_name&gt;#进入工程目录cd &lt;project_name&gt;#安装依赖npm install#运行npm run dev 2.setup组件中所用到的数据、的方法均配置在setupz setup返回值有两种： 返回一个对象，则对象中的属性、方法在模板中可直接使用 返回一个渲染函数：则可自定义渲染函数 Vue2.x配置（data,methods,computed…）可以访问setup中的属性、方法 setup中不能访问Vue2.x配置（data,methods,computed…） 重名setup优先 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;h1&gt;test&lt;/h1&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;sayhello&#x27;&gt;hello&lt;/button&gt;&lt;/template&gt;&lt;script&gt;//import &#123;h&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup()&#123; let name = &#x27;name&#x27;; let age = 18; function sayhello()&#123; alert(&quot;hello&quot;); &#125; //返回对象，常用 return &#123; name, age, sayhello &#125; // 返回渲染函数，不常用 return ()=&gt;h(&quot;h2&quot;,&quot;test2&quot;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; setup参数： props：组件外部传过来且组件内部声明接收了的属性 context： attrs：组件外部传过来未在props中声明接收的属性this.$attrs slots：收到的插槽内容this.$slots emit：分发自定义事件的函数，相当于this.$emit 父组件App.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;Demo @hello=&quot;showHello&quot; msg=&quot;hello,world!&quot;&gt; &lt;template v-slot:abc&gt; &lt;h1&gt;APP&lt;/h1&gt; &lt;/template&gt; &lt;/Demo&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive&#125; from &#x27;vue&#x27;;import Demo from &#x27;./components/Demo&#x27;export default &#123; name: &#x27;App&#x27;, components:&#123; Demo &#125;, setup(props,context)&#123; let data = ref(&#123; a:1 &#125;) function showHello(value) &#123; alert(`收到参数$&#123;value&#125;`); &#125; //返回对象，常用 return &#123; data, showHello &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件Demo.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;h1&gt;demo&lt;/h1&gt; &lt;p&gt;&#123;&#123;props.msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;context.attrs.msg2&#125;&#125;&lt;/p&gt; &lt;slot name=&quot;abc&quot;&gt;&lt;/slot&gt; &lt;button @click=&quot;test&quot;&gt;调用showHello&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive&#125; from &#x27;vue&#x27;;export default &#123; name:&#x27;demo&#x27;, props:[&quot;msg&quot;], emits:[&quot;hello&quot;], setup(props,context)&#123; console.log(props) console.log(context.attrs) console.log(context.emit) console.log(context.slots) let data = reactive(&#123; &#125;) function test()&#123; context.emit(&#x27;hello&#x27;,666) &#125; //返回对象，常用 return &#123; data, props, context, test &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.ref响应式数据 基本类型的数据：响应式靠Object.defineProperty()的get和set实现 对象类型的数据：使用reactive函数 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;h1&gt;test&lt;/h1&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;job.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;change&#x27;&gt;change&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup()&#123; let name = ref(&#x27;name&#x27;); let age = ref(18); let job = ref(&#123; name:&#x27;job&#x27;, salary:3000 &#125;); function change()&#123; name.value=&quot;lrc&quot;; age.value=22; job.value.name=&quot;123&quot; job.value.salary = 2000; console.log(name,age); &#125; //返回对象，常用 return &#123; name, age, job, change &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; reactive函数： 作用：定义一个对象类型的响应式数据 语法：const 代理对象 = reactive(源对象)，返回一个Proxy代理对象 reactive定义的响应式数据是深层次的 基于ES6的Proxy实现，通过代理对象对源对象内部进行操作 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;h1&gt;test&lt;/h1&gt; &lt;p&gt;&#123;&#123;job.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;job.salary&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;test&#125;&#125;&lt;/p&gt; &lt;button @click=&#x27;change&#x27;&gt;change&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup()&#123; let job = reactive(&#123; name:&#x27;job&#x27;, salary:3000 &#125;); let test = reactive([0,1,2]) function change()&#123; job.name=&quot;123&quot; job.salary = 2000; test[0] = 2; test.push(4); &#125; //返回对象，常用 return &#123; job, test, change &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4.响应式实现通过Proxy拦截对象中任意属性的变化 通过Reflect对被代理对象的属性进行操作 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; let person = &#123; a:1, b:2 &#125; const p = new Proxy(person,&#123; //tagrget:源对象，这里指person //propName:对象名 get(target,propName)&#123; console.log(`有人读取了p的$&#123;propName&#125;属性`) //return target[propName]; return Reflect.get(target,propName); &#125;, //修改和追加属性时调用 set(target,propName,value)&#123; console.log(`有人修改了p的$&#123;propName&#125;属性，值为$&#123;value&#125;`); //target[propName]=value; Reflect.set(target,propName,value); &#125;, //删除属性时调用 deleteProperty(target,propName)&#123; console.log(`有人修删除了p的$&#123;propName&#125;属性`); //return delete target[propName]; return Reflect.deleteProperty(target,propName); &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 5.计算属性12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;data.person.firstName&quot;&gt;&lt;br/&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;data.person.lastName&quot;&gt; &lt;p&gt;全名：&lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive, computed&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let data = reactive(&#123; person:&#123; firstName:&#x27;&#x27;, lastName:&#x27;&#x27; &#125; &#125;) //计算属性,简写不考虑计算属性被修改 // let fullName = computed(()=&gt;&#123; // return data.person.firstName+data.person.lastName; // &#125;) //计算属性，完整写法 let fullName = computed(&#123; get()&#123; return data.person.firstName+&quot;-&quot;+data.person.lastName; &#125;, set(value)&#123; const nameArr = value.split(&quot;-&quot;); data.person.firstName = nameArr[0]; data.person.lastName = nameArr[1]; &#125; &#125;) return &#123; data, fullName &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.watch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;msg+=&#x27;!&#x27;&quot;&gt;msg&lt;/button&gt; &lt;p&gt;&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,watch&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let sum = ref(0); let msg = ref(&quot;hello&quot;) let person = reactive(&#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125;) //监视一个ref定义的基本类型 // watch(sum,(newValue,oldValue)=&gt;&#123; // console.log(&quot;sum值变化&quot;,newValue,oldValue) // &#125;) //监视多个ref定义的基本类型 // watch([sum,msg],(newValue,oldValue)=&gt;&#123; // console.log(&quot;sum或msg值变化&quot;,newValue,oldValue) // &#125;) //监视一个reactive定义的对象类型， //不能正确获得oldValue //强制开启深度监视,&#123;deep:false&#125;无效 // watch(person,(newValue,oldValue)=&gt;&#123; // console.log(&quot;person值变化&quot;,newValue,oldValue) // &#125;,&#123;deep:false&#125;) //监视object中的某一个属性 watch(()=&gt;person.age,(newValue,oldValue)=&gt;&#123; console.log(&quot;person.age值变化&quot;,newValue,oldValue) &#125;) return &#123; sum, msg, person &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.watchEffect不用指明监视哪个属性，监视的回调中用到哪个属性就监视哪个属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;msg+=&#x27;!&#x27;&quot;&gt;msg&lt;/button&gt; &lt;p&gt;&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,watch,watchEffect&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let sum = ref(0); let msg = ref(&quot;hello&quot;) let person = reactive(&#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125;) watchEffect(()=&gt;&#123; const x1 = sum.value; const x2 = person.job.salary console.log(&quot;watchEffect执行&quot;) &#125;) return &#123; sum, msg, person &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 8.生命周期Vue2.x生命周期钩子 其中beforeDestory变为beforeUnmount，destoryed变为unmounted 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;h1&gt;demo&lt;/h1&gt; &lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive&#125; from &#x27;vue&#x27;;export default &#123; name:&#x27;demo&#x27;, setup(props,context)&#123; let sum = ref(0); //返回对象，常用 return &#123; sum &#125; &#125;, beforeCreate()&#123; console.log(&quot;beforeCreate&quot;); &#125;, created()&#123; console.log(this.sum); console.log(&quot;created&quot;); &#125;, beforeMount() &#123; console.log(&quot;beforeMount&quot;); &#125;, mounted()&#123; console.log(&quot;mounted&quot;); &#125;, beforeUpdate()&#123; console.log(&quot;beforeUpdate&quot;); &#125;, updated()&#123; console.log(&quot;updated&quot;); &#125;, beforeUnmount()&#123; console.log(&quot;beforeUnmount&quot;); &#125;, unmounted()&#123; console.log(&quot;unmounted&quot;); &#125; &#125;&lt;/script&gt; Composition API形式的生命周期钩子 beforeCreate&#x3D;&#x3D;&#x3D;&gt;setup() created&#x3D;&#x3D;&#x3D;&gt;setup() beforeMount&#x3D;&#x3D;&#x3D;&gt;onBeforeMount mounted&#x3D;&#x3D;&#x3D;&gt;onMounted beforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate updated&#x3D;&#x3D;&#x3D;&gt;onUpdated beforeUnmount&#x3D;&#x3D;&#x3D;&gt;onBeforeUnmount unmounted&#x3D;&gt;onUnmounted 例如： 123456789101112131415161718192021222324&lt;template&gt; &lt;h1&gt;demo&lt;/h1&gt; &lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,onBeforeMount&#125; from &#x27;vue&#x27;;export default &#123; name:&#x27;demo&#x27;, setup(props,context)&#123; let sum = ref(0); onBeforeMount(()=&gt;&#123; console.log(&quot;onBeforeMount&quot;) &#125;) //返回对象，常用 return &#123; sum &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 9.自定义hook本质是一个函数，把setup函数中使用的Composition API进行封装 hooks&#x2F;usePoint.js 1234567891011121314151617181920import &#123;reactive,onMounted,onBeforeUnmount&#125; from &#x27;vue&#x27;;export default function ()&#123; let point = reactive(&#123; x:0, y:0 &#125;) function savePoint(event)&#123; console.log(event.pageX,event.pageY); point.x=event.pageX point.y=event.pageY &#125; onMounted(()=&gt;&#123; window.addEventListener(&#x27;click&#x27;,savePoint) &#125;) onBeforeUnmount(()=&gt;&#123; window.removeEventListener(&#x27;click&#x27;,savePoint) &#125;) return point;&#125; Demo.vue 123456789101112131415161718192021&lt;template&gt; &lt;h1&gt;demo&lt;/h1&gt; &lt;p&gt;当前鼠标点击的坐标x:&#123;&#123;point.x&#125;&#125;,y:&#123;&#123;point.y&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;;import usePoint from &#x27;../hooks/usePoint&#x27;;export default &#123; name:&#x27;demo&#x27;, setup(props,context)&#123; let point = usePoint(); //返回对象，常用 return &#123; point &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 10.toRef与toRefs创建一个ref对象，其value值指向另一个对象中的某一属性 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;name:&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;person.name:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;age:&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;p&gt;person.age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;job.salary:&#123;&#123;job.salary&#125;&#125;&lt;/p&gt; &lt;p&gt;person.job.salary:&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,toRef,toRefs&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let person = reactive(&#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125;) return &#123; person, //age:toRef(person,&#x27;age&#x27;) ...toRefs(person) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 11.shallowReactive和shallowRef只考虑对象地一层的reactive和ref，shallowRef只处理基本类型 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;sum:&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt; &lt;p&gt;person.name:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;person.age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;person.job.salary:&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,shallowReactive,shallowRef&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let sum = shallowRef(0); let person = shallowReactive(&#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125;) return &#123; person, sum &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12.readonly与shallowReadonly只读和浅层只读 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;sum:&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt; &lt;p&gt;person.name:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;person.age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;person.job.salary:&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,readonly,shallowReadonly&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let sum = ref(0); let person = reactive(&#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125;) //person = readonly(person) person = shallowReadonly(person) return &#123; person, sum &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 13.toRaw与markRowtoRaw：将一个由reactive生成的响应式对象转换为普通对象 markRaw：标记一个对象，使其永远不会成为响应式对象 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;p&gt;sum:&#123;&#123;sum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;sum++&quot;&gt;sum++&lt;/button&gt; &lt;p&gt;person.name:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;person.age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;person.job.salary:&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive,toRaw,markRaw&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let sum = ref(0); let person = &#123; name:&#x27;abc&#x27;, age:18, job:&#123; salary:20 &#125; &#125; person = markRaw(person); person = reactive(person); //person = toRaw(person) return &#123; person, sum &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 14.customRef创建一个自定义耳朵ref，并对其依赖项跟踪和更新触发进行显式控制 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt; &lt;h3&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,customRef&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let timer; function myRef(value)&#123; return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; //追踪数据变化 track() return value; &#125;, set(newValue)&#123; //防抖 clearTimeout(timer); timer = setTimeout(()=&gt;&#123; value = newValue //通知vue重新解析模板 trigger() &#125;,500) &#125; &#125; &#125;); &#125; let keyWord = myRef(&quot;hello&quot;); //person = toRaw(person) return &#123; keyWord &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 15.provide与inject给后代组件传递数据 祖组件App.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;div class=&quot;app&quot;&gt; &lt;p&gt;我是App&lt;/p&gt; &lt;Son&gt;&lt;/Son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Son from &#x27;./components/Son&#x27;import &#123;reactive,provide&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, components:&#123; Son &#125;, setup(props,context)&#123; let person = reactive(&#123; name:&#x27;123&#x27;, age:12, job:&#123; salary:2000 &#125; &#125;) //给自己的后代组件传数据 provide(&#x27;person&#x27;,person) return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.app&#123; background-color: gray; padding: 10px;&#125;&lt;/style&gt; 子组件Son.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;div class=&quot;son&quot;&gt; &lt;p&gt;我是son&lt;/p&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &#x27;./Child&#x27;export default &#123; name: &#x27;App&#x27;, components:&#123; Child &#125;, setup(props,context)&#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.son&#123; background-color: red; padding: 10px;&#125;&lt;/style&gt; 孙组件Child.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;!--- Vue3可以没有根元素 ---&gt; &lt;div class=&quot;child&quot;&gt; &lt;p&gt;我是child&lt;/p&gt; &lt;p&gt;person.name:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;person.age:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;person.job.salary:&#123;&#123;person.job.salary&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;person.age++&quot;&gt;age++&lt;/button&gt; &lt;button @click=&quot;person.job.salary++&quot;&gt;salary++&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,inject&#125; from &#x27;vue&#x27;;export default &#123; name: &#x27;App&#x27;, setup(props,context)&#123; let person = inject(&#x27;person&#x27;) return &#123; person &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.child&#123; background-color: blue; padding: 10px;&#125;&lt;/style&gt; 16.响应式数据判断 isRef：检查一个值是否为一个ref对象 isReactive：检查一个对象是否是由reactive创建的响应式代理 isReadonly：检查一个对象是否是由readonly创建的只读代理 isProxy：检查一个对象是否由reactive或者readonly方法创建的代理 17.新组件17.1Fragment组件Vue2中组件必须有一个根标签 Vue3中组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中 17.2Teleport组件传送html结构到指定位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;isShow = true&quot;&gt;点我弹窗&lt;/button&gt; &lt;!-- 也可写css选择器，但一般写body --&gt; &lt;teleport to=&#x27;body&#x27;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;h4&gt;一些内容&lt;/h4&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;;export default &#123; setup()&#123; let isShow = ref(false); return&#123; isShow &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.mask&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: rgba(0, 0, 0, 0.5);&#125;.dialog&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); text-align: center; width: 200px; height: 200px; background-color: green;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Kubernetes学习笔记","slug":"k8s-note","date":"2023-09-07T13:22:22.000Z","updated":"2024-05-14T14:08:49.717Z","comments":false,"path":"k8s-note/","permalink":"http://example.com/k8s-note/","excerpt":"","text":"1.基本概念1.1Master节点apiserver：集群统一入口，以restful方式，交给etcd存储 scheduler：节点调度，选择worker节点应用部署 controller-manager：处理集群中常规后台任务，一个资源对应一个控制器 etcd：存储系统，用于保存集群相关的数据 1.2worker节点kubelet：master派到node节点的代表，管理本机容器 kube-proxy：提供网络代理，负载均衡等操作 1.3Pod 最小部署单元 一组容器的集合 共享网络 生命周期是短暂的 1.4Controller 确保预期的Pod副本数量 无状态应用部署 有状态应用部署 一次性任务和定时任务 1.5Service 定义一组Pod的访问规则 2.环境搭建安装版本，采用kubeadm搭建，k8s的组件均运行在docker容器中 ubuntu kubernetes docker 22.04 LTS 1.23.5-00 5:20.10.14~3-0~ubuntu-jammy 2.1安装指定版本docker参考docker官网安装教程 12345678910111213141516171819202122232425262728293031323334353637#准备工具sudo apt-get updatesudo apt-get install ca-certificates curl gnupg#Add Docker’s official GPG keysudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg#set up the repositoryecho \\ &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null#查看版本号sudo apt-cache madison docker-ce#安装指定版本sudo apt-get install docker-ce=5:20.10.14~3-0~ubuntu-jammy docker-ce-cli=5:20.10.14~3-0~ubuntu-jammy containerd.io#docker compose,docker官网安装教程中有,可不安装，不影响运行#sudo apt-get install containerd.io docker-buildx-plugin docker-compose-plugin#换仓库地址，写入配置文件sudo vim /etc/docker/daemon.json#写入加速器地址&#123; &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com/&quot;]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker#配置docker,kubernetes默认设置cgroup驱动(cgroupdriver)为&quot;systemd&quot;，而docker服务的cgroup驱动默认为&quot;cgroupfs&quot;，建议将其修改为&quot;systemd&quot;，与kubernetes保持一致#再次修改daemon.json，在其后添加一行&quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]sudo vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com/&quot;], &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker 2.2关闭swap分区12sudo vim /etc/fstab#注释掉 /swapfile 所在行，然后重启计算机即可永久关闭swap 2.3安装kubeadm、kubectl和kubelet kubelet: k8s sh的核心服务 kubeadm: 这个是用于快速安装 k8s 的一个集成工具，我们在master1和worker1上的 k8s 部署都将使用它来完成。 kubectl: k8s 的命令行工具，部署完成之后后续的操作都要用它来执行 1234567891011121314#更新apt源sudo apt-get update#使apt支持ssl传输sudo apt-get install -y apt-transport-https#下载gpg密钥curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -#添加apt源sudo apt-add-repository &quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot;#查看可安装版本sudo apt-cache madison kubectl#安装指定版本sudo apt-get install kubelet=1.23.5-00 kubeadm=1.23.5-00 kubectl=1.23.5-00#阻止自动更新sudo apt-mark hold kubelet kubeadm kubectl 2.4配置Master节点1234567891011121314151617181920212223242526#查看集群使用的容器镜像kubeadm config images list#拉取所需镜像sudo kubeadm config images pull --image-repository=registry.aliyuncs.com/google_containers#初始化#配置项说明：#--apiserver-advertise-address k8s 中服务apiserver的部署地址，如果不填写，默认是本机#--image-repository 拉取的 docker 镜像源，因为初始化的时候kubeadm会去拉 k8s 的很多组件来进行部署，所以需要指定国内镜像源，下不然会拉取不到镜像#--pod-network-cidr k8s采用的节点网络，该参数指定了为pod节点分配的虚拟ip网段#--kubernetes-version: 这个是用来指定你要部署的 k8s 版本的，一般不用填，不过如果初始化过程中出现了因为版本不对导致的安装错误的话，可以用这个参数手动指定kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version=v1.23.5 --pod-network-cidr=192.168.0.0/16 --apiserver-advertise-address=192.168.121.130#初始化mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config#查看集群节点kubectl get nodes#查看集群状态kubectl get cs#以上步骤安装完后，机器搭建起来了，但状态还是NotReady状态，master机器需要安装网络插件Calico#下面是一个网上别人整理好的资源清单，之间运行k8s会在docker中拉起相应的服务kubectl apply -f https://docs.projectcalico.org/v3.21/manifests/calico.yaml#再次查看集群节点，状态变为Readykubectl get nodes#查看集群状态kubectl get cs 输出信息如下，执行其中的mkdir，cp等命令，最后的输出kubeadm join命令用于worker节点加入集群 1234567891011121314151617181920Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configAlternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.confYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.121.130:6443 --token 1uwxx8.zkr71sdz5uu7z2t1 \\ --discovery-token-ca-cert-hash sha256:5d0df7efc1d8895ec4c93e7d926738d4311fd36b6f14b18dffbaf4e07d66213d 2.5配置worker节点12345678910111213141516171819202122232425262728#更新apt源sudo apt-get update#使apt支持ssl传输sudo apt-get install -y apt-transport-https#下载gpg密钥curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -#添加apt源sudo apt-add-repository &quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot;#查看可安装版本sudo apt-cache madison kubectl#安装指定版本sudo apt-get install kubelet=1.23.5-00 kubeadm=1.23.5-00 kubectl=1.23.5-00#阻止自动更新sudo apt-mark hold kubelet kubeadm kubectl#加入集群sudo kubeadm join 192.168.121.130:6443 --token 1uwxx8.zkr71sdz5uu7z2t1 \\ --discovery-token-ca-cert-hash sha256:5d0df7efc1d8895ec4c93e7d926738d4311fd36b6f14b18dffbaf4e07d66213d#查看token和hashkubeadm token listkubeadm token inspect &lt;token名称&gt;#新建tokenkubeadm token create --print-join-command#部署完后在master节点查看kubectl get nodes#输出如下:#NAME STATUS ROLES AGE VERSION#lzy-virtual-machine Ready control-plane,master 35m v1.23.5#worker-node1 Ready &lt;none&gt; 2m7s v1.23.5 3.基本操作3.1Kubectl使用环境准备，将主节点的.kube&#x2F;config文件复制到worker节点中 12345678#使用命令验证kubectl get nodes#查看命令kubectl --help#查看生成的标签kubectl get node --show-labels#给节点node2打上标签env=prodkubectl label node node2 env=prod 3.2集群资源清单用于资源编排 yaml文件组成部分，由控制器定义和被控制对象组成，示例： 123456789101112131415161718192021222324#控制器定义apiVersion: apps/v1kind: Deployment #资源类型metadata: name: nginx-deployment namespace: defaultspec: replicas: 1 #副本数量 selector: matchLabels: app: nginx#被控制对象 template: #Pod模板 metadata: #Pod元数据 labels: app: nginx spec: containers: #容器配置 - name: nginx #容器名称 image: nginx:1.18 #容器镜像 imagePullPolicy: IfNotPresent #获取镜像的策略 ports: #Pod的重启策略 - containerPort: 80 #容器需要监听的端口号 restartPolicy: Always #Pod的重启策略 常用字段说明 参数名 数据类型 说明 apiVersion String 指k8s API的版本，可以用kubectl api-versions命令查看,一般为v1 kind String 指yaml文件定义的资源类型和角色，比如Pod metadata Object 元数据对象 metadata.name String 元数据对象的名字，这里由我们编写 metadata.namespace String 元数据对象的命名空间 spec Object 详细定义对象 spec.containers[] list 容器列表 spec.containers[].name String 容器名 spec.containers[].name String 镜像名称 spec.containers[].imagePullPolicy String 容器镜像拉取策略，Always、Never、Ifnotpresent 1234567#应用资源清单文件kubectl apply -f fileName.yaml#使用kubectl create命令生成yaml文件kubectl create deployment test --image=nginx:1.18 -o yaml --dry-run &gt; my1.yaml#使用kubectl get命令导出yaml文件#旧版本为kubectl get deploy nginx-app -o=yaml --export &gt; my2.yamlkubectl get deploy nginx-app -o=yaml &gt; my2.yaml 3.3NameSpace 实现资源隔离 属于逻辑隔离 属于管理边界 不属于网络边界 可以针对每个namespace做资源隔离 123456789101112131415161718#查看命名空间kubectl get namespace#以下为输出#NAME STATUS AGE#default Active 2d17h#kube-node-lease Active 2d17h#kube-public Active 2d17h#kube-system Active 2d17h#其中default为用户创建pod的默认命名空间#kube-public 为所有用户均可访问的命名空间，包括未认证用户#kube-node-lease 为kubernetes集群节点租约状态，v1.13加入#kube-system kubernetes集群使用的命名空间#创建命名空间kubectl create namespace test#删除命名空间kubectl delete namespace test 3.4Pod一个Pod中的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如namespace,cgroups 或者其他的隔离资源。 pod实现共享网络机制：Pod中首先自动创建Pause容器（根容器），再创建业务容器，并将业务容器加入根容器，让所有业务容器在同一个namespace中，实现网络共享 pod实现共享存储机制：引入数据卷概念Volumn，实现共享存储 查看pod 123456#查看podkubectl get pods#或kubectl get pods --namespace default#进入podkubectl exec -it [podName] bash 创建pod，以部署nginx应用为例 12#拉取镜像sudo docker pull nginx:1.18 资源清单nginx.yaml 12345678910111213apiVersion: v1kind: Podmetadata: name: pod1 namespace: defaultspec: containers: - name: nginx-pod image: nginx:1.18 imagePullPolicy: IfNotPresent ports: - name: nginxport containerPort: 80 创建pod，创建pod时scheduler会使用调度算法将pod分配给相应的node 12345678910#应用资源清单文件kubectl apply -f nginx.yaml#查看是否成功创建kubectl get pods -o wide#输出为#NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES#pod1 1/1 Running 0 3m34s 192.168.180.193 worker-node1 &lt;none&gt; &lt;none&gt;#可通过192.168.180.193进行访问#删除podkubectl delete pods pod1 -n default 3.5Controller控制器在集群上管理和运行容器的对象 当pod出现问题时，会把pod重新拉起，以达到用户的期望状态 常见Pod控制器 控制器名称 作用 Deployment 声明式更新控制器，用于发布无状态应用 ReplicaSet 副本集控制器，用于对Pod进行副本规模扩大或裁剪 StatefulSet 有状态副本集，用于发布有状态应用 DaemonSet 在k8s集群每一个Node上运行一个副本，用于发布监控或日志收集类等应用 Job 运行一次性作业任务 CronJob 运行周期性作业任务 12345678#创建Deployment控制器类型应用kubectl apply -f deployment.yaml#查看kubectl get deployment#删除，使用kubectl delete pods直接删除pod会被重新拉起kubectl delete deployment nginx-app#弹性伸缩kubectl scale deployment nginx-deployment --replicas==2 3.5.1部署无状态应用（Deployment） pod之间没有顺序 所有pod共享存储 pod名字包含随机数字 service都有ClusterIP,可以负载均衡 12kubectl apply -f deployment.yamlkubectl expose deployment nginx-deployment --type=NodePort --target-port=80 --port=8000 示例资源清单deployment.yaml 123456789101112131415161718192021222324#控制器定义apiVersion: apps/v1kind: Deployment #资源类型metadata: name: nginx-deployment namespace: defaultspec: replicas: 1 #副本数量 selector: matchLabels: app: nginx#被控制对象 template: #Pod模板 metadata: #Pod元数据 labels: app: nginx spec: containers: #容器配置 - name: nginx #容器名称 image: nginx:1.18 #容器镜像 imagePullPolicy: IfNotPresent #获取镜像的策略 ports: #Pod的重启策略 - containerPort: 80 #容器需要监听的端口号 restartPolicy: Always #Pod的重启策略 3.5.2部署有状态应用（StatefulSet） 部署、扩展、更新、删除都要有顺序 每个pod都有自己存储，所以都用volumeClaimTemplates，为每个pod都生成一个自己的存储，保存自己的状态 pod名字始终是固定的 service没有ClusterIP，是headlessservice（打通app之间的通信，而又不需要对外暴露），所以无法负载均衡，返回的都是pod名，所以pod名字都必须固定 能不用StatefulSet，就不要用 示例资源清单statefulSet.yaml 12345678910111213141516171819202122232425#控制器定义apiVersion: apps/v1kind: StatefulSet #资源类型metadata: name: nginx-statefulset namespace: defaultspec: serviceName: nginx replicas: 2 #副本数量 selector: matchLabels: app: nginx#被控制对象 template: #Pod模板 metadata: #Pod元数据 labels: app: nginx spec: containers: #容器配置 - name: nginx #容器名称 image: nginx:1.18 #容器镜像 imagePullPolicy: IfNotPresent #获取镜像的策略 ports: #Pod的重启策略 - containerPort: 80 #容器需要监听的端口号 restartPolicy: Always #Pod的重启策略 Service资源清单service.yaml 12345678910111213apiVersion: v1kind: Service #资源类型metadata: name: nginx labels: app: nginxspec: ports: - port: 80 name: web clusterIP: None selector: app: nginx #对应statefulSet.yaml中的spec.template.metadata.labels.app 3.6Service作用: 防止Pod失联（服务发现） 定义一组Pod访问策略（负载均衡） service类型： ClusterIP：默认，分配一个集群内部可以访问的虚拟ip NodePort：在每个Node上分配一个端口作为外部访问入口 LoadBalancer：对外访问应用使用，比NodePort更强大，公有云实现负载均衡，控制器 ExternalName：把集群外部的服务引入到集群内部中来，即实现集群内部pod和集群外部的服务进行通信 12345678910111213141516#创建应用kubectl apply -f deployment.yaml#创建service#target-port指pod的端口，port指外部访问端口kubectl expose deployment nginx-app --type=ClusterIP --target-port=80 --port=8000#查看kubectl get service#删除servicekubectl delete service nginx-app#创建NodePort类型service，使外网也能访问，在每个Node上分配一个端口作为外部访问入口kubectl expose deployment nginx-app --type=NodePort --target-port=80 --port=8000#kubectl get service查看service，输出如下#NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE#kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 2d22h#nginx-app NodePort 10.111.139.105 &lt;none&gt; 8000:31062/TCP 2s#外网可通过任意节点的31062端口访问nginx 3.7Secret作用：加密数据存在etcd里，让Pod容器以挂载Volume方式进行访问 1kubectl apply -f secret.yaml 3.7.1secret.yaml(数据要自己base64加密)12345678apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: bHp5 password: MTIzNDU2 以变量形式挂载到pod 123kubectl apply -f pod.yamlkubectl exec -it mypod bashecho $SECRET_USERNAME pod.yaml 12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: nginx image: nginx:1.18 imagePullPolicy: IfNotPresent ports: - containerPort: 80 env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 3.7.2以Volume的形式挂载到Pod中123456kubectl apply -f pod.yamlkubectl exec -it mypod bashcd /etc/foolscat usernamecat password pod.yaml 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: nginx image: nginx:1.18 imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: #挂载位置 - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: #数据来源 - name: foo secret: secretName: mysecret 3.8ConfigMap作用：存储不加密数据到etcd，让Pod以变量或者Volume挂载到容器中 3.8.1以变量形式挂载到pod1234kubectl apply -f configMap.yaml kubectl apply -f pod.yamlkubectl exec -it mypod bashecho $INFO configMap.yaml 123456apiVersion: v1kind: ConfigMapmetadata: name: my-configdata: config.info: info pod.yaml 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: nginx image: nginx:1.18 imagePullPolicy: IfNotPresent ports: - containerPort: 80 env: - name: INFO valueFrom: configMapKeyRef: name: my-config key: config.info 3.8.2以volume形式挂载到Pod中1234567#创建ConfigMapkubectl create configmap redis-config --from-file=redis.properties#查看kubectl get cmkubectl apply -f pod.yamlkubectl exec -it mypod bashcat /etc/config/redis.properties redis.properties 123redis.host=127.0.0.1redis.port=6379redis.password=123456 pod.yaml 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: nginx image: nginx:1.18 imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: #挂载位置 - name: config-volume mountPath: &quot;/etc/config&quot; readOnly: true volumes: #数据来源 - name: config-volume configMap: name: redis-config 附录：yaml具体解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# yaml格式的pod定义文件完整内容：apiVersion: v1 #必选，版本号，例如v1kind: Pod #必选，Podmetadata: #必选，元数据 name: string #必选，Pod名称 namespace: string #必选，Pod所属的命名空间 labels: #自定义标签 - name: string #自定义标签名字 annotations: #自定义注释列表 - name: stringspec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口号名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存清楚，容器启动的初始可用数量 livenessProbe: #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged:false restartPolicy: #[Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork:false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: &#123;&#125; #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://example.com/categories/Kubernetes/"}],"tags":[]},{"title":"Go学习随笔","slug":"go-note","date":"2023-09-05T07:10:20.000Z","updated":"2024-05-14T16:21:15.529Z","comments":false,"path":"go-note/","permalink":"http://example.com/go-note/","excerpt":"","text":"1.安装下载sdk：https://golang.google.cn/dl/ 将bin目录加入环境变量 go run编译并直接运行程序，不产生可执行文件，运行速度慢。 go build会产生exe文件，运行速度快。 gofmt输出格式化的文件。 gofmt -w将格式化的文件重新写入。 12345678910#GOROOT/src：该目录保存了Go标准库代码。#GOPATH/src：该目录保存了应用自身的代码和第三方依赖的代码。go get和go install命令会下载go代码到GOPATH。export GOROOT=/home/lzy/Downloads/goexport PATH=$GOROOT/bin:$PATHexport GOPATH=/home/lzy/Documents/GoProjects/GOPATH#GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。#GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。#GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct // 使用七牛云的 2.数据类型2.1整数类型有符号整数int8、int16、int32、int64 无符号整数uint8、uint16、uint32、uint64 1234567891011package mainimport ( &quot;fmt&quot; &quot;unsafe&quot;)func main() &#123; var n = 100 fmt.Printf(&quot;n的数据类型是%T,n占用的字节是%d&quot;, n, unsafe.Sizeof(n))&#125; 2.2浮点类型float32单精度，float64双精度 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var a float32 var b float64 = 3.1415e2 var c float32 fmt.Scanf(&quot;%f&quot;, &amp;a) //吸收回车 fmt.Scanln() fmt.Scanf(&quot;%f&quot;, &amp;c) fmt.Printf(&quot;%f,%f,%f\\n&quot;, a, b, c) fmt.Println(a)&#125; 2.3字符型rune：与int32一样，表示一个unicode码 byte：与uint8等价，存储字符 2.4布尔型bool两个值true，false 2.5字符串string，字符串一旦赋值便不可修改 双引号，会识别转义字符 反引号，以字符串的原生形式输出 123456789package mainimport &quot;fmt&quot;func main() &#123; var c string = &quot;hello\\n&quot; var d string = `world\\n` fmt.Printf(&quot;%s%s&quot;, c, d)&#125; 拼接字符串 12345678910111213package mainimport ( &quot;bytes&quot; &quot;fmt&quot;)func main() &#123; var buffer bytes.Buffer buffer.WriteString(&quot;lc&quot;) buffer.WriteString(&quot;dsb&quot;) fmt.Printf(&quot;buffer.String():%v\\n&quot;, buffer.String())&#125; 切片 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; str := &quot;hello,world&quot; n := 2 m := 4 fmt.Printf(&quot;str[n]:%c\\n&quot;, str[n]) //截取下标从n到m-1的字符串 fmt.Printf(&quot;str[n:m]:%s\\n&quot;, str[n:m]) //截取下标从n到len(s)-1的字符串 fmt.Printf(&quot;str[n:]:%s\\n&quot;, str[n:]) //截取下标从0到m-1的字符串 fmt.Printf(&quot;str[:m]:%s\\n&quot;, str[:m])&#125; 3.数组12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; var a = [...]int&#123;1, 2, 3&#125; var b [3]string fmt.Printf(&quot;a:%T\\n&quot;, a) fmt.Printf(&quot;b:%T\\n&quot;, b) fmt.Printf(&quot;a:%v\\n&quot;, a) fmt.Printf(&quot;b:%v\\n&quot;, b)&#125;func f() &#123; var a = [5]int&#123;1, 2, 3, 4, 5&#125; for i, v := range a &#123; fmt.Printf(&quot;i:%d,v:%d\\n&quot;, i, v) &#125;&#125; 4.切片1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; f1()&#125;func f1() &#123; //var slice = []int&#123;1,2,3&#125; var slice []int = make([]int, 1) fmt.Printf(&quot;%p\\n&quot;, slice) fmt.Printf(&quot;%p\\n&quot;, &amp;slice[0]) slice = append(slice, 1, 2, 3) fmt.Printf(&quot;%p\\n&quot;, slice) fmt.Printf(&quot;%p\\n&quot;, &amp;slice[0]) for i, v := range slice &#123; fmt.Printf(&quot;i:%d,v:%d\\n&quot;, i, v) &#125;&#125; 5.map123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; test()&#125;func test() &#123; //var m1 map[string]int = make(map[string]int) m1 := make(map[string]int) m1[&quot;key1&quot;] = 1 m1[&quot;key2&quot;] = 2 m1[&quot;key3&quot;] = 3 for k, v := range m1 &#123; fmt.Printf(&quot;k=%v,v=%v\\n&quot;, k, v) &#125; delete(m1, &quot;key3&quot;) //判断key是否存在 value, ok := m1[&quot;key1&quot;] fmt.Printf(&quot;%v,%v\\n&quot;, value, ok) value, ok = m1[&quot;key3&quot;] fmt.Printf(&quot;%v,%v\\n&quot;, value, ok)&#125; 6.函数多返回值 1234567891011package mainimport &quot;fmt&quot;func main() &#123; ret, ret2 := add(1, 2) fmt.Printf(&quot;%d,%d\\n&quot;, ret, ret2)&#125;func add(a int, b int) (int, int) &#123; return a + b, a - b&#125; 可变参数 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; f2(&quot;name&quot;, 1, 2, 3, 4, 5, 6)&#125;func f2(name string, args ...int) &#123; fmt.Printf(&quot;name:%v\\n&quot;, name) for _, value := range args &#123; fmt.Printf(&quot;value:%v\\n&quot;, value) &#125;&#125; 闭包：定义在函数内部的函数 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)func main() &#123; //在f的生命周期内，x一直有效 var f = add() fmt.Printf(&quot;%v\\n&quot;, f(10))&#125;func add() func(int) int &#123; var x int return func(y int) int &#123; x = x+y return y &#125;&#125; 7.defer语句特性 (1)用于注册延迟调用 (2)这些调用直到return前才被执行 (3)多个defer语句，按先进后出的方式执行 (4)defer语句的变量，在defer声明时就决定了 用途：(1)关闭文件句柄、(2)锁资源释放、(3)数据库连接释放 12345678910111213package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Printf(&quot;start!\\n&quot;) defer fmt.Printf(&quot;defer1\\n&quot;) defer fmt.Printf(&quot;defer2\\n&quot;) defer fmt.Printf(&quot;defer3\\n&quot;) fmt.Printf(&quot;end!\\n&quot;)&#125; 8.init函数(1)先于main函数自动执行 (2)没有输入参数和返回值 (3)包的每个源文件也可以有多个init函数 (4)同一个包的init执行顺序没有明确定义，不同包的init函数安装包导入的依赖关系决定执行顺序 9.指针12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main() &#123; a := []int&#123;1, 2, 3&#125; var b *[]int var c []int b = &amp;a c = a fmt.Printf(&quot;a:%p\\n&quot;, a) fmt.Printf(&quot;b:%p\\n&quot;, b) fmt.Printf(&quot;&amp;a:%p\\n&quot;, &amp;a) fmt.Printf(&quot;&amp;a[0]:%p\\n\\n&quot;, &amp;a[0]) a = append(a, 4, 5, 6) fmt.Printf(&quot;a:%p\\n&quot;, a) fmt.Printf(&quot;b:%p\\n&quot;, b) fmt.Printf(&quot;&amp;a:%p\\n&quot;, &amp;a) fmt.Printf(&quot;&amp;a[0]:%p\\n&quot;, &amp;a[0]) fmt.Println(a) fmt.Println(*b) fmt.Println(c)&#125; 10.自定义类型123456789//类型定义type NewType Type//类型别名type NewName = Type//结构体type Node struct &#123; value int next *Node&#125; 11.方法一种特殊的函数，定义于struct之上(与struct关联、绑定)，被称为struct的接受者 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;type Node struct &#123; value int next *Node&#125;func main() &#123; node := Node&#123;next: nil, value: 1&#125; node.getValue() fmt.Printf(&quot;%d\\n&quot;, node.value) node.get() fmt.Printf(&quot;%d\\n&quot;, node.value)&#125;func (per Node) getValue() int &#123; per.value = 3 return per.value&#125;func (per *Node) get() int &#123; //per = new(Node) per.value = 2 return per.value&#125; 12.接口12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;type USB interface &#123; read() write()&#125;type computer struct &#123; name string&#125;type phone struct &#123; name string&#125;func (c computer) read() &#123; fmt.Printf(&quot;computer %s read!\\n&quot;, c.name)&#125;func (c computer) write() &#123; fmt.Printf(&quot;computer %s write!\\n&quot;, c.name)&#125;func (p phone) read() &#123; fmt.Printf(&quot;computer %s read!\\n&quot;, p.name)&#125;func (p phone) write() &#123; fmt.Printf(&quot;computer %s write!\\n&quot;, p.name)&#125;func main() &#123; var c USB var p USB c = computer&#123;name: &quot;c&quot;&#125; p = phone&#123;name: &quot;p&quot;&#125; c.read() c.write() p.read() p.write()&#125; 13.go mod12345678910111213141516go env -w GO111MODULE=ongo env -w GO111MODULE=offgo env -w GO111MODULE=autogo env -w GOPROXY=https://goproxy.cn,direct//初始化模块go mod init &lt;项目模块名称&gt;//处理依赖关系go mod tidy//将依赖包复制到项目下的vendor目录go mod vendor//显示依赖关系go list -m all//显示详细依赖关系go list -m -json all//下载依赖go mod download [path@version] go mod使用 新建文件加 go mod init &lt;项目模块名称&gt; 编写代码 go mod tidy 运行 14.并发编程14.1协程Goroutines是并发运行的函数 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func showMsg(msg string) &#123; for i := 0; i &lt; 3; i++ &#123; fmt.Printf(&quot;msg:%v\\n&quot;, msg) time.Sleep(time.Millisecond * 100) &#125;&#125;func main() &#123; //创建一个协程 go showMsg(&quot;java&quot;) go showMsg(&quot;go&quot;) time.Sleep(time.Millisecond * 500)&#125; 14.2通道用于在goroutine之间共享数据，需要在声明通道时指定数据类型，在任何给定时间只有一个goroutine可以访问数据项，因此不会发生数据竞争 1234//无缓存int通道，无缓存的通道只有在有人接收值的时候才能发送值Unbuffered := make(chan int)//有缓存int通道buffered := make(chan int, 10) sync.WaitGroup 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc recv(c chan int) &#123; fmt.Printf(&quot;recv\\n&quot;) for value := range c &#123; fmt.Printf(&quot;value:%v\\n&quot;, value) &#125; defer wg.Done()&#125;func send(c chan int) &#123; defer wg.Done() //不关闭会产生死锁 defer close(c) for i := 0; i &lt; 5; i++ &#123; c &lt;- i fmt.Printf(&quot;send:%v\\n&quot;, i) &#125;&#125;func main() &#123; ch := make(chan int) go recv(ch) wg.Add(1) go send(ch) wg.Add(1) wg.Wait() //time.Sleep(time.Millisecond * 500)&#125; 14.3runtime12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc show(str string) &#123; defer wg.Done() for i := 0; i &lt; 5; i++ &#123; if i &gt;= 4 &#123; //退出协程 runtime.Goexit() &#125; fmt.Printf(&quot;%s\\n&quot;, str) &#125;&#125;func main() &#123; fmt.Printf(&quot;当前CPU核心数:%v\\n&quot;, runtime.NumCPU()) //设置最大核心数 //runtime.GOMAXPROCS(1) go show(&quot;java&quot;) wg.Add(1) for i := 0; i &lt; 2; i++ &#123; //有权执行任务，让给其他子协程 runtime.Gosched() fmt.Printf(&quot;golang\\n&quot;) &#125; wg.Wait()&#125; 14.4Mutex锁 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var i int = 100var wg sync.WaitGroupvar lock sync.Mutexfunc add() &#123; defer wg.Done() //不加锁结果可能出错 lock.Lock() i += 1 fmt.Printf(&quot;i++:%v\\n&quot;, i) time.Sleep(time.Millisecond * 3) lock.Unlock()&#125;func sub() &#123; defer wg.Done() lock.Lock() i -= 1 fmt.Printf(&quot;i--:%v\\n&quot;, i) time.Sleep(time.Millisecond * 2) lock.Unlock()&#125;func main() &#123; for i := 0; i &lt; 100; i++ &#123; wg.Add(1) go add() wg.Add(1) go sub() &#125; wg.Wait() fmt.Printf(&quot;end:%v\\n&quot;, i)&#125; 14.5select实现异步io 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc send(chanInt chan int, chanStr chan string) &#123; chanInt &lt;- 100 chanStr &lt;- &quot;hello&quot; defer wg.Done() defer close(chanInt) defer close(chanStr)&#125;func recv(chanInt chan int, chanStr chan string) &#123; defer wg.Done() for i := 0; i &lt; 2; &#123; select &#123; case r := &lt;-chanInt: fmt.Printf(&quot;chanInt:%v\\n&quot;, r) i++ case r := &lt;-chanStr: fmt.Printf(&quot;chanStr:%v\\n&quot;, r) i++ default: fmt.Printf(&quot;default\\n&quot;) &#125; &#125;&#125;func main() &#123; chanInt := make(chan int) chanStr := make(chan string) go recv(chanInt, chanStr) wg.Add(1) go send(chanInt, chanStr) wg.Add(1) wg.Wait()&#125;","categories":[{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"}],"tags":[]},{"title":"Docker学习笔记","slug":"docker-note","date":"2023-08-26T00:52:20.000Z","updated":"2024-05-14T13:57:11.172Z","comments":false,"path":"docker-note/","permalink":"http://example.com/docker-note/","excerpt":"","text":"1.安装官网教程地址：https://docs.docker.com/engine/install/ubuntu/ 1234567891011121314151617181920212223#删除旧版本sudo apt-get remove docker docker-engine docker.io containerd runc#更新apt包索引并安装包，允许apt通过HTTPS使用存储库sudo apt-get updatesudo apt-get install ca-certificates curl gnupg#添加Docker官方GPG密钥sudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg#echo \\ &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null #安装最新版本sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin#查看版本验证是否成功安装docker -v#卸载sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 2.镜像加速器配置123456789#写入配置文件sudo vim /etc/docker/daemon.json#写入加速器地址&#123; &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com/&quot;]&#125;sudo systemctl daemon-reloadsudo systemctl restart docker 3.docker命令3.1docker服务相关命令12345678910111213141516#启动dockersystemctl start docker#查看docker命令systemctl status docker#停止docker服务systemctl stop docker#重启docker服务systemctl restart docker#开机自启动dockersystemctl enable docker#查看信息docker info#查看占有空间docker system df#清除build cachedocker builder prune 3.2docker镜像相关文件12345678910#查看本地镜像docker images#搜索镜像docker search [镜像名]#下载镜像docker pull [镜像名]:[版本号]#删除镜像docker rmi [IMAGE_ID]#删除所有镜像docker rmi `docker images -q` 3.3docker容器相关命令12345678910111213141516171819202122#创建容器,参数：#-i交互式操作#-t终端，为容器分配一个伪输入终端#-d后台运行并返回容器ID#--name名称，#-P，随机端口映射#-p，指定端口映射，-p hostPort:containerPort8sudo docker run -id --name=u1 ubuntu:22.04 /bin/bash#查看容器docker ps -a#启动容器docker start [容器ID]#停止容器docker stop [容器ID]#重启容器docker restart [容器ID]#进入容器docker exec -it [容器ID] /bin/bash#删除容器docker rm -f [容器ID]#拷贝容器文件至宿主机docker cp [容器ID]:[容器内路径] [宿主机路径] 3.4容器数据卷创建启动容器时，使用-v参数设置数据卷 1234567891011docker run ... -v [宿主机目录(文件)]:[容器内目录(文件)]#例如sudo docker run -id --name=u1 -v /home/lzy/Documents/docker_data:/data ubuntu:22.04 /bin/bash#容器只能读不能写，默认为rw,可读可写sudo docker run -id --name=u1 -v /home/lzy/Documents/docker_data:/data ubuntu:22.04:ro /bin/bash#继承容器的卷规则sudo docker run -id --name=u1 --volumes-from [要继承容器的名称] /bin/bash#Docker挂载主机目录访问如果出现cannot open directory .: Permission denied#解决办法：在挂载目录后多加一个--privileged=true参数即可#查看挂载是否成功docker inspect [容器id] 4.docker应用部署以部署mysql为例 1234567#-p端口映射，-e MYSQL_ROOT_PASSWORD初始化密码docker run -id -p 3307:3306 --name=mysql1 \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/logs:/logs \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456\\mysql:5.7 5.Dockerfile5.1Docker镜像原理Linux文件系统由bootfs和rootfs两部分组成 bootfs：包含bootloader(引导加载程序)和kernel(内核) rootfs：root文件系统，包含的就是典型Linux系统中的&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件 Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs,并使用宿主机的bootfs 第二层是root文件系统rootfs，称为base image,再往上可以叠加其他的镜像 统一文件系统技术能够将不同的层整合成一个文件系统，为这些层提供一个统一的视角 一个镜像可以放在另一个镜像的上面，位于下面的镜像称为父镜像，最底部的镜像称为基础镜像 当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器 5.2容器镜像转换12345678910#导出镜像docker save -o [压缩文件名称] [镜像名称]:[版本号]#导入镜像docker load -i [压缩文件名称]#导出容器docker export [容器ID] &gt; [文件名.tar]#导入容器docker import [文件名.tar] [镜像名:版本号]#提交容器副本，使其成为一个新的镜像‘docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; [容器ID] [要创建的目标镜像名:版本号] 5.3Dockerfile Dockerfile是一个文本文件 包含了一系列指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 5.4Dockerfile关键字FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像，第一条必须的from MAINTAINER：镜像维护者的姓名和邮箱地址 WORKDIR：指在创建容器后，终端默认登录进来的工作目录 RUN：docker build时运行的命令 CMD：docker run时运行的命令，Dockerfile中可以有多条CMD指令，但只有最有一条生效 EXPOSE：对外暴露的端口 USER：指定该镜像以什么用户去执行，默认为root ENV：设置环境变量，在后续的指令中，就可以使用这个环境变量，如ENV MY_PATH &#x2F;usr&#x2F;mytest COPY：从上下文目录中复制文件或者目录到容器里指定路径 123COPY &lt;源路径1&gt;... &lt;目标路径&gt;#例如COPY hom.txt /mydir/ ADD：和 COPY 的使用格类似，但会自动解压 ENTRYPOINT：类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 假设已通过 Dockerfile 构建了 nginx:test 镜像： 1234FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 12345#不传参运行，相当于nginx -c /etc/nginx/nginx.confdocker run nginx:test#传参运行#相当于nginx -c /etc/nginx/new.conf（假设容器内已有此文件）docker run nginx:test -c /etc/nginx/new.conf 尝试部署一个简单的springboot项目 Main.java 123456789101112package org.test.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Main &#123; public static void main(String[] args)&#123; SpringApplication.run(Main.class,args); &#125;&#125; TestController.java 12345678910111213141516package org.test.hello.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;@Controller@ResponseBodypublic class TestController &#123; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET,produces = &quot;application/json;charset=utf-8&quot;) public String hello()&#123; return &quot;hello, world!&quot;; &#125;&#125; pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringBoot版本管理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.12.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Dockerfile 12345FROM java:8MAINTAINER lzy &lt;lha602@163.com&gt;ADD hello.jar app.jarEXPOSE 8080CMD java -jar app.jar build 1234#buildsudo docker build -f ./helloDockerfile -t hello:1.0 .#尝试运行sudo docker run -id -p 8081:8080 --name=hello1 hello:1.0 6.docker networkbridge模式：Docker服务启动时，默认会创建一个名称为 docker0 网桥（其上有一个名称为 docker0 内部接口）。Docker每启动一个容器时会根据Docker网桥的网段分配给容器一个ip地址。虚拟网桥，默认为该模式。 host模式：容器不会虚拟出自己的网卡，使用宿主机的IP和端口。 none模式：容器有独立的Network namespace，但没有对其进行任何网络设置。 container模式：和一个指定的容器共享IP、端口范围。 12345678910111213141516171819#查看网络docker network ls# 创建网络时是可以添加一系列参数的：# --driver：驱动程序类型# --gateway：主子网的IPV4和IPV6的网关# --subnet：代表网段的CIDR格式的子网# mynet：自定义网络名称docker network create --driver=bridge --gateway=192.168.137.1 --subnet=192.168.137.0/16 mynet#查看网络数据源docker network inspect 网络名称#删除网络docker network rm 网络名称 #将容器连接到指定网络docker network connect 网络名称 容器名称#断开容器的网络docker network disconnect 网络名称 容器名称#创建并运行容器时指定网络#自定义网络本身维护好了主机名和ip的关系docker run -id -p 8081:8080 --network myNetWork --name tomcat1 tomcat:8.5","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[]},{"title":"Nginx配置chatgpt代理","slug":"nginx-chatgpt-proxy","date":"2023-06-23T14:18:13.000Z","updated":"2024-05-14T14:20:03.722Z","comments":false,"path":"nginx-chatgpt-proxy/","permalink":"http://example.com/nginx-chatgpt-proxy/","excerpt":"","text":"1.安装nginxnginx下载地址：http://nginx.org/en/download.html 123456789101112#解压文件tar zxvf nginx-1.18.0.tar.gz#进入解压后的文件夹目录cd nginx-1.18.0#安装依赖#apt-get install -y zlib1g zlib1g-dev#apt-get install -y gccapt-get install libpcre3 libpcre3-devapt-get install opensslapt-get install libssl-dev#检查配置./configure --prefix=/home/nginx --with-http_ssl_module 不缺依赖的检查结果： 123456789101112131415161718Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: &quot;/home/nginx&quot; nginx binary file: &quot;/home/nginx/sbin/nginx&quot; nginx modules path: &quot;/home/nginx/modules&quot; nginx configuration prefix: &quot;/home/nginx/conf&quot; nginx configuration file: &quot;/home/nginx/conf/nginx.conf&quot; nginx pid file: &quot;/home/nginx/logs/nginx.pid&quot; nginx error log file: &quot;/home/nginx/logs/error.log&quot; nginx http access log file: &quot;/home/nginx/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot; 继续安装： 1234#编译make#安装make install 验证，进入指定安装目录下的sbin： 123456789cd sbin#启动nginx./nginx#快速停止./nginx -s stop#优雅关闭，关闭之前完成已经接受的连接请求./nginx -s quit#重新加载配置./nginx -s reload 2.配置代理2.1与nginx通过http协议通信nginx.conf关键部分配置 123456789server &#123; listen 80; server_name localhost; location /v1/ &#123; proxy_pass https://api.openai.com/v1/; proxy_ssl_server_name on; proxy_set_header Host api.openai.com; &#125;&#125; 2.2与nginx通过https协议通信使用openssl生成RSA密钥文件 1openssl genrsa -out private.key 2048 创建CSR文件 1openssl req -new -key private.key -out server.csr 创建自签名证书 1openssl x509 -req -days 3650 -in server.csr -signkey private.key -out server.crt nginx.conf关键部分配置 123456789101112server &#123; listen 443 ssl; server_name localhost; proxy_read_timeout 60s; ssl_certificate /home/secret/server.crt; ssl_certificate_key /home/secret/private.key; location /v1/ &#123; proxy_pass https://api.openai.com/v1/; proxy_ssl_server_name on; proxy_set_header Host api.openai.com; &#125;&#125; 自签证书会被认为不可信，使用okhttp访问时会报错，需要设置忽略证书认证，具体方法可参考https://blog.csdn.net/qq_39486119&#x2F;article&#x2F;details&#x2F;120187646","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"}],"tags":[]},{"title":"Neo4j学习笔记","slug":"neo4j","date":"2023-04-16T13:44:43.000Z","updated":"2024-05-14T14:17:53.228Z","comments":false,"path":"neo4j/","permalink":"http://example.com/neo4j/","excerpt":"","text":"1.图数据库基于图论实现的一种NoSQL数据库，其数据存储结构和查询方式都是以图论为基础的，图数据库主要用于存储更多的连接数据。 NoSQL数据库大致可分为四种 分类 数据模型 优势 劣势 julio 键值数据库 哈希表 查找速度快 数据无结构化，通常只被当作字符串或二进制数据 Redis 列存储数据库 列式数据存储 查找速度快，支持分布横向扩展，数据压缩率高 功能相对受限 HBase 文档型数据库 键值对扩展 数据要求不严格，表结构可变，不需要预定义表结构 查询性能不高，缺乏统一的查询语法 MongoDB 图数据库 节点和关系组成的图 利用图结构相关算法 可能需要对整个图做计算，不利于图数据分布存储 Neo4j、janusGraph 1.1属性图模型Neo4j图数据库遵循属性图模型来存储和管理其数据 属性图模型规则 表示节点，关系和属性中的数据 节点和关系都包含属性 关系连结节点 属性是键值对 节点用圆圈表示，关系用方向键表示 关系具有方向：单向和双向 每个关系包含“开始节点”或“从节点”和“结束节点”或“到节点” 2.安装neo4j1234567#解压压缩版，3.几的版本要求jdk8,4.几的要求jdk11tar -zxvf neo4j-community-3.5.28-unix.tar.gz#将Neo4j作为控制台应用程序运行&lt;NEO4J_HOME&gt;/bin/neo4j console#将Neo4j作为服务进行安装&lt;NEO4J_HOME&gt;/bin/neo4j install-service#浏览器访问http://localhost:7474/，初始帐号密码均为neo4j 3.Neo4j - CQL使用Neo4j的Cypher语言是为处理图形数据而构建的，CQL代表Cypher查询语言。 CQL命令 用法 CREATE 创建节点、关系和属性 MATCH 检索有关节点、关系和属性数据 RETURN 返回查询结果 WHERE 提供条件过滤检索数据 DELETE 删除节点和关系 REMOVE 删除节点和关系的属性 ORDER BY 排序检索数据 SET 添加或更新标签 ### 3.1CREATE 创建节点及节点间的关系 1234567891011//&lt;node-name&gt;为别名，只限该查询语句中使用可省略，&lt;lable-name&gt;为节点标签名称CREATE (&lt;node-name&gt;:&lt;lable-name&gt;)//创建带属性值的节点CREATE ( &lt;node-name&gt;:&lt;lable-name&gt; &#123; &lt;Property1-name&gt;:&lt;Property1-Value&gt;\\ ...... &lt;Property2-name&gt;:&lt;Property2-Value&gt; &#125;) 3.2MATCH1234567//查询Student下的内容MATCH(stu:student)RETURN stu//查询STudent标签下name为李畅的内容MATCH(stu:student)WHERE stu.name=&#x27;李畅&#x27;RETURN stu 3.3关系123456789101112//创建节点及其关系CREATE (&lt;node1-name&gt;:&lt;label1-name&gt;)- [&lt;relationship-name&gt;:&lt;relationship-label-name&gt;] -&gt;(&lt;node2-name&gt;:&lt;label2-name&gt;)//例如节点及单个关系CREATE(stu1:student&#123;id:1,name:&#x27;康弘&#x27;,age:20&#125;)-[r:friend]-&gt;(stu2:student&#123;id:2,name:&#x27;赵沛增&#x27;,age:21&#125;)//创建节点及多个关系CREATE(stu1:student&#123;id:1,name:&#x27;李畅&#x27;,age:20&#125;),(stu2:student&#123;id:2,name:&#x27;刘智宇&#x27;,age:21&#125;),(stu1)-[:father]-&gt;(stu2),(stu2)-[:son]-&gt;(stu1)//为已经存在的节点添加关系MATCH(stu1:student&#123;id:1,name:&#x27;李畅&#x27;,age:20&#125;),(stu2:student&#123;id:2,name:&#x27;刘智宇&#x27;,age:21&#125;)CREATE (stu1)-[:father]-&gt;(stu2),(stu1)&lt;-[:son]-(stu2) 3.4DELETE删除节点及节点间的关系，一般配和MATCH使用 123456789//删除所有节点及关系MATCH p = ()--&gt;()DELETE p//删除两个节点间的全部关系MATCH (stu1:student&#123;name:&#x27;刘智宇&#x27;&#125;)-[r]-(stu2:student&#123;name:&#x27;李畅&#x27;&#125;)DELETE r//删除两个节点的指定类型的关系MATCH (stu1:student&#123;name:&#x27;刘智宇&#x27;&#125;)-[r:son]-(stu2:student&#123;name:&#x27;李畅&#x27;&#125;)DELETE r 3.5REMOVE 删除节点或关系的标签 删除节点或关系的属性 123456//删除节点的属性MATCH(book:Book)REMOVE book.name,book.price//删除节点MATCH(book:Book)REMOVE book:tool,book:Book 4.springboot整合neo4j4.1引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;&lt;/dependency&gt; 4.2编写配置123456spring: data: neo4j: uri: bolt://localhost:7687 username: neo4j password: 123456 4.3实体类和关系类 Student.java 123456789101112131415161718192021222324252627package org.study.bean;import lombok.Data;import org.neo4j.ogm.annotation.GeneratedValue;import org.neo4j.ogm.annotation.Id;import org.neo4j.ogm.annotation.NodeEntity;import org.neo4j.ogm.annotation.Property;@Data@NodeEntity(label = &quot;student&quot;)public class Student &#123; @Id @GeneratedValue private Long id; @Property private String name; @Property private Integer age; public Student(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; StudentRelationship.java 123456789101112131415161718192021222324package org.study.bean;import lombok.Data;import org.neo4j.ogm.annotation.*;@Data@RelationshipEntity(type = &quot;室友&quot;)public class StudentRelationship &#123; @Id @GeneratedValue private Long id; @StartNode private Student start; @EndNode private Student end; public StudentRelationship(Student start, Student end) &#123; this.start = start; this.end = end; &#125;&#125; 4.4Repository接口StudentRelationshipRepository.java 123456789101112131415package org.study.dao;import org.springframework.data.neo4j.annotation.Query;import org.springframework.data.neo4j.repository.Neo4jRepository;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import org.study.bean.StudentRelationship;@Repositorypublic interface StudentRelationshipRepository extends Neo4jRepository&lt;StudentRelationship,Long&gt;&#123; //自定义语句 @Query(&quot;MATCH(stu1:student&#123;name:&#123;from&#125;&#125;),(stu2:student&#123;name:&#123;to&#125;&#125;)CREATE(stu1)-[:室友]-&gt;(stu2)&quot;) public void createRelationship(@Param(&quot;from&quot;)String from,@Param(&quot;to&quot;)String to);&#125; StudentRepository.java 123456789package org.study.dao;import org.springframework.data.neo4j.repository.Neo4jRepository;import org.springframework.stereotype.Repository;import org.study.bean.Student;@Repositorypublic interface StudentRepository extends Neo4jRepository&lt;Student,Long&gt; &#123;&#125; 4.5测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.study.controller;import com.alibaba.fastjson.JSON;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.study.bean.Student;import org.study.bean.StudentRelationship;import org.study.dao.StudentRelationshipRepository;import org.study.dao.StudentRepository;import java.util.Optional;@Controller@ResponseBodypublic class TestController &#123; @Autowired private StudentRepository studentRepository; @Autowired private StudentRelationshipRepository relationshipRepository; @RequestMapping(value = &quot;/api/match-service/test&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=utf-8&quot;) public String test()&#123; //查找节点 Optional&lt;Student&gt; result =studentRepository.findById(7L); //创建节点 Student student = new Student(&quot;郝靖东&quot;,22); Student student1 = new Student(&quot;黄俊威&quot;,21); studentRepository.save(student); studentRepository.save(student1); //搭建关系 StudentRelationship relationship = new StudentRelationship(student,student1); //第一种方式 relationshipRepository.save(relationship); //第二种方式 relationshipRepository.createRelationship(&quot;黄俊威&quot;,&quot;郝靖东&quot;); //删除节点 studentRepository.deleteById(8L); return JSON.toJSONString(result.get()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"RabbitMQ用法笔记","slug":"rabbitmq-note","date":"2023-03-01T15:20:20.000Z","updated":"2024-05-14T14:42:50.631Z","comments":false,"path":"rabbitmq-note/","permalink":"http://example.com/rabbitmq-note/","excerpt":"","text":"1.RabbitMQAMQP，即Advanced Message Queuing Protocol，是一个网络协议，是应用层协议的一个开放标准 Broker：接收和分发消息的应用 Virtual host：出于多用户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange &#x2F; queue等 Connection：publisher &#x2F; consumer 和broker之间的TCP连接 Channel：如果每次访问都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的。Channel是在connection 内部建立的逻辑连接，Channel作为轻量级的Connection减少了操作系统建立TCP Connection的开销。 2.安装官网 1234567891011121314151617181920212223242526272829# 安装 erlangsudo apt-get install erlang-nox# 查看relang语言版本，成功执行则说明relang安装成功erl# 安装成功自动启动sudo apt-get install rabbitmq-server# Active: active (running) 说明处于运行状态systemctl status rabbitmq-server # 或service rabbitmq-server status # --------- 常用命令 ---------# 启动 | 停止 | 重启sudo service rabbitmq-server start sudo service rabbitmq-server stop sudo service rabbitmq-server restart # 启用插件sudo rabbitmq-plugins enable rabbitmq_management # 重启sudo service rabbitmq-server restart# 至此，http://localhost:15672 应该可以访问了，默认账户是 guest/guest 3.简单模式依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.6.0&lt;/version&gt;&lt;/dependency&gt; 生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package producer;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); // 创建队列 channel.queueDeclare(&quot;hello&quot;,false,false,false,null); /** * 1.queue:队列名称 * 2.durable:是否持久化 * 3.exclusive: * 是否独占，只能有一个消费者监听这个队列 * 当Connection关闭时，是否删除队列 * 4.autoDelete:是否自动删除,没有消费者时自动删除队列 * 5.arguments:参数 */ // 发送消息 String message = &quot;hello, world!&quot;; channel.basicPublish(&quot;&quot;,&quot;hello&quot;,null,message.getBytes()); /** * 1.exchange:交换机名称 * 2.routingkey:路由名称 * 3.props:配置信息 * 4.body:发送消息数据 */ // 释放资源 channel.close(); connection.close(); &#125;&#125; 消费者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package consumer;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); // 创建队列 // channel.queueDeclare(&quot;hello&quot;,false,false,false,null); /** * 1.queue:队列名称 * 2.durable:是否持久化 * 3.exclusive: * 是否独占，只能有一个消费者监听这个队列 * 当Connection关闭时，是否删除队列 * 4.autoDelete:是否自动删除,没有消费者时自动删除队列 * 5.arguments:参数 */ // 接收消息 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(&quot;consumerTag:&quot;+consumerTag); System.out.println(&quot;Exchange:&quot;+envelope.getExchange()); System.out.println(&quot;RoutingKey:&quot;+envelope.getRoutingKey()); System.out.println(&quot;properties:&quot;+properties); System.out.println(&quot;body:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(&quot;hello&quot;,true,consumer); /** * 1.queue:队列名称 * 2.autoAck:是否自动确认 * 3.callback:回调对象 */ // 释放资源 // channel.close(); // connection.close(); &#125;&#125; 4.工作模式类似简单模式，多个消费者同时连接一个队列，相互竞争 5.发布&#x2F;订阅模式生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package producer;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); String queueName1 = &quot;test1&quot;; String queueName2 = &quot;test2&quot;; String exchangeName = &quot;fanout&quot;; // 创建队列 channel.queueDeclare(queueName1,false,false,false,null); channel.queueDeclare(queueName2,false,false,false,null); // 创建交换机 channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,false,false,false,null); /** * 1.exchange:交换机名称 * 2.type：交换机类型 * DIRECT:定向 * FANOUT:广播 * TOPIC:通配符 * HEADERS:参数匹配 * 3.durable:是否持久化 * 4.autoDelete:自动删除 * 5.internal:内部使用 * 6.arguments:参数 */ // 绑定队列和交换机 channel.queueBind(queueName1,&quot;fanout&quot;,&quot;&quot;); channel.queueBind(queueName2,&quot;fanout&quot;,&quot;&quot;); /** * 1.queue:队列名称 * 2.exchange:交换机名称 * 3.routingKey:路由键，绑定规则，如果交换机类型为fanout,则routingKey为“” */ String message = &quot;message:你好吗？&quot;; channel.basicPublish(exchangeName,&quot;&quot;,null,message.getBytes()); // 释放资源 channel.close(); connection.close(); &#125;&#125; 消费者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package consumer;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); // 创建队列 // channel.queueDeclare(&quot;hello&quot;,false,false,false,null); /** * 1.queue:队列名称 * 2.durable:是否持久化 * 3.exclusive: * 是否独占，只能有一个消费者监听这个队列 * 当Connection关闭时，是否删除队列 * 4.autoDelete:是否自动删除,没有消费者时自动删除队列 * 5.arguments:参数 */ // 接收消息 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;// System.out.println(&quot;consumerTag:&quot;+consumerTag);// System.out.println(&quot;Exchange:&quot;+envelope.getExchange());// System.out.println(&quot;RoutingKey:&quot;+envelope.getRoutingKey());// System.out.println(&quot;properties:&quot;+properties); System.out.println(&quot;body:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(&quot;test1&quot;,true,consumer); /** * 1.queue:队列名称 * 2.autoAck:是否自动确认 * 3.callback:回调对象 */ // 释放资源 // channel.close(); // connection.close(); &#125;&#125; 6.路由模式发送消息的routingKey与接收消息的routingKey一致才能收到 生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package producer;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); String queueName1 = &quot;test1&quot;; String queueName2 = &quot;test2&quot;; String exchangeName = &quot;fanout&quot;; // 创建队列 channel.queueDeclare(queueName1,false,false,false,null); channel.queueDeclare(queueName2,false,false,false,null); // 创建交换机 channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT,false,false,false,null); /** * 1.exchange:交换机名称 * 2.type：交换机类型 * DIRECT:定向 * FANOUT:广播 * TOPIC:通配符 * HEADERS:参数匹配 * 3.durable:是否持久化 * 4.autoDelete:自动删除 * 5.internal:内部使用 * 6.arguments:参数 */ // 绑定队列和交换机 channel.queueBind(queueName1,&quot;fanout&quot;,&quot;info&quot;); channel.queueBind(queueName2,&quot;fanout&quot;,&quot;info&quot;); channel.queueBind(queueName2,&quot;fanout&quot;,&quot;error&quot;); /** * 1.queue:队列名称 * 2.exchange:交换机名称 * 3.routingKey:路由键，绑定规则，如果交换机类型为fanout,则routingKey为“” */ String message = &quot;message:你好吗？&quot;; String error = &quot;error&quot;; channel.basicPublish(exchangeName,&quot;info&quot;,null,message.getBytes()); channel.basicPublish(exchangeName,&quot;error&quot;,null,error.getBytes()); // 释放资源 channel.close(); connection.close(); &#125;&#125; 消费者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package consumer;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Main &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;/itcast&quot;); factory.setUsername(&quot;test&quot;); factory.setPassword(&quot;test&quot;); Connection connection = factory.newConnection(); // 创建channel Channel channel = connection.createChannel(); // 创建队列 // channel.queueDeclare(&quot;hello&quot;,false,false,false,null); /** * 1.queue:队列名称 * 2.durable:是否持久化 * 3.exclusive: * 是否独占，只能有一个消费者监听这个队列 * 当Connection关闭时，是否删除队列 * 4.autoDelete:是否自动删除,没有消费者时自动删除队列 * 5.arguments:参数 */ // 接收消息 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;// System.out.println(&quot;consumerTag:&quot;+consumerTag);// System.out.println(&quot;Exchange:&quot;+envelope.getExchange());// System.out.println(&quot;RoutingKey:&quot;+envelope.getRoutingKey());// System.out.println(&quot;properties:&quot;+properties); System.out.println(&quot;body:&quot;+new String(body)); &#125; &#125;; channel.basicConsume(&quot;test1&quot;,true,consumer); /** * 1.queue:队列名称 * 2.autoAck:是否自动确认 * 3.callback:回调对象 */ // 释放资源 // channel.close(); // connection.close(); &#125;&#125; 7.Topics通配符模式 8.结合SpringBoot生产者： application.yml 123456789spring: rabbitmq: host: 127.0.0.1 port: 5672 username: test password: test virtual-host: /itcastserver: port: 8080 12345678910111213141516171819202122package producer.controller;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import producer.config.RabbitMQConfig;@Controller@ResponseBodypublic class RabbitMQTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @RequestMapping(&quot;/test&quot;) public String test()&#123; rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME,&quot;match&quot;,&quot;hello&quot;); return &quot;success&quot;; &#125;&#125; RabbitMQConfig.java 123456789101112131415161718192021222324252627282930313233package producer.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RabbitMQConfig &#123; public final static String EXCHANGE_NAME = &quot;fanout&quot;; public final static String QUEUE_NAME = &quot;queue&quot;; //1.交换机 @Bean(&quot;bootExchange&quot;) public Exchange bootExchange()&#123; return ExchangeBuilder.fanoutExchange(EXCHANGE_NAME).durable(false).build(); &#125; //2.队列 @Bean(&quot;bootQueue&quot;) public Queue bootQueue()&#123; return QueueBuilder.nonDurable(QUEUE_NAME).build(); &#125; //3.绑定交换机和队列 @Bean public Binding bindQueueExchange(@Qualifier(&quot;bootQueue&quot;) Queue queue,@Qualifier(&quot;bootExchange&quot;) Exchange exchange)&#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;&quot;).noargs(); &#125;&#125; 消费者： 1234567891011121314package consumer.rabbitmq;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class RabbitMQListener &#123; @RabbitListener(queues = &quot;queue&quot;) public void ListenerQueue(Message message)&#123; System.out.println(new String(message.getBody())); &#125;&#125;","categories":[{"name":"消息队列","slug":"消息队列","permalink":"http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"Nacos搭配Gateway用法","slug":"nacos-gateway","date":"2023-02-19T15:30:41.000Z","updated":"2024-05-14T14:35:17.281Z","comments":false,"path":"nacos-gateway/","permalink":"http://example.com/nacos-gateway/","excerpt":"","text":"1.Nacosnacos下载 2.1Nacos Server启动1234#进入bin文件夹bash -f ./startup.sh#关闭./shutdown.sh 访问链接：http://127.0.0.1:8848/nacos/index.html 1.2Nacos client配置settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven-&gt;Ignored Files OrderApplication.java 123456789101112131415161718192021222324package order;import javafx.beans.property.adapter.JavaBeanBooleanPropertyBuilder;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplication//@EnableDiscoveryClientpublic class OrderApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(OrderApplication.class,args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; OrderController.java 12345678910111213141516171819202122package order.controllor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired private RestTemplate restTemplate; @RequestMapping(&quot;/add&quot;) public String add()&#123; System.out.println(&quot;下单成功!&quot;); String msg = restTemplate.getForObject(&quot;http://stock-service/stock/reduct&quot;,String.class); System.out.println(msg); return &quot;hello, world!&quot;; &#125;&#125; application.yml 12345678910111213141516171819server: port: 8084spring: application: #应用名称，nacos会将该名称当作服务名称 name: stock-service cloud: nacos: server-addr: 127.0.0.1:8848 discovery: username: nacos password: nacos namespace: public #为false时为永久实例，宕机了也不会删除实例 #ephemeral: false #分组管理，默认EFAULT_GROUP #group: DEFAULT_GROUP #权重 #weight: 1 pom.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud&lt;/artifactId&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;order-nacos&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.Gateway2.1基本使用pom.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud&lt;/artifactId&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;name&gt;gateway&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml 12345678910111213141516171819server: port: 8088spring: application: name: api-gateway cloud: #gateway配置 gateway: #路由规则,数据类型为List routes: #路由的唯一标识 - id: order_route #需要转发的地址 uri: http://127.0.0.1:8081 #断言规则,用于路由规则的匹配 predicates: - Path=/order/**# filters:# - StripPrefix=1 2.2结合nacos12345678910111213141516171819202122232425server: port: 8088spring: application: name: api-gateway cloud: #gateway配置 gateway: #路由规则,数据类型为List routes: #路由的唯一标识 - id: order_route #需要转发的地址 uri: lb://order-service #断言规则,用于路由规则的匹配 predicates: - Path=/order/**# filters:# - StripPrefix=1 nacos: discovery: server-addr: 127.0.0.1:8848 username: nacos password: nacos namespace: public","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]},{"title":"Flex弹性盒子用法","slug":"flex-note","date":"2023-02-02T08:45:20.000Z","updated":"2024-05-14T13:58:34.247Z","comments":false,"path":"flex-note/","permalink":"http://example.com/flex-note/","excerpt":"","text":"1.Flex布局Flex常用属性 flex-direction flex-wrap flew-flow justify-content align-items align-content 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 1.1flex-direction1flex-direction: row | row-reverse | column | column-reverse 包含四个属性值 row: 默认值，表示沿水平方向，由左到右。 row-reverse ：表示沿水平方向，由右到左 column：表示垂直方向，由上到下 column-reverse:表示垂直方向，由下到上 1.2flex-wrap1flex-wrap: nowrap | wrap | wrap-reverse nowrap：不换行，元素宽度失效，强行显示在一行 wrap：正常换行，第一个位于第一行的第一个 wrap-reverse：反向换行，第一个位于最下面 1.3justify-content1justify-content: flex-start | flex-end | center | space-between | space-around flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧间隔相等 1.4align-items1align-items: flex-start | flex-end | center | baseline | stretch flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：如果项目为设置高度或为auto，将占满整个容器的高度 1.5align-content控制多行项目，设置后align-items会失效 1align-content: flex-start | flex-end | center | space-between | space-around flex-start：与交叉轴起点对齐 flex-end：与交叉轴终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间 space-around：轴线占满整个交叉轴","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Vue2学习笔记","slug":"Vue2-note","date":"2023-01-17T04:38:20.000Z","updated":"2024-05-14T14:39:40.916Z","comments":false,"path":"Vue2-note/","permalink":"http://example.com/Vue2-note/","excerpt":"","text":"1.安装手脚架1npm install -g @vue/cli 2.模板语法1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; name:&quot;你好&quot; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 3.数据绑定 单向绑定 bind 数据只能从data流向页面 双向绑定 v-model 数据不仅能从data流向页面，还能从页面流向data 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h2&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h1&gt;单向数据绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;str&quot;&gt; &lt;!-- 简写 --&gt; &lt;!-- &lt;input type=&quot;text&quot; v-bind:value=&quot;str&quot;&gt; --&gt; &lt;h1&gt;双向数据绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;str&quot;&gt; &lt;!-- 简写 --&gt; &lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const v = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; name:&quot;你好&quot;, str:&#x27;&#x27; &#125; &#125;) console.log(v)&lt;/script&gt;&lt;/html&gt; 4.MVVM模型 M：模型(model)：对应data中的数据 V：视图(View)：模板 Vm：视图模型(ViewModel)：Vue实例对象 5.数据代理的实现 vue中的数据放在实例_data上 _data相当于下面例子中的number 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; let number = 18 let person = &#123; name:&#x27;zhangsan&#x27;, sex:&#x27;男&#x27; &#125; Object.defineProperty(person,&#x27;age&#x27;,&#123; // value:18, // enumerable:true,//是否可枚举，默认为false // writable:true,//是否可被修改，默认为false // configurable:true,//是否可被删除，默认为false // 当有人读取age时调用get函数，且age的值为返回值 get()&#123; console.log(&#x27;读取age&#x27;) return number &#125;, // 当有人修改age时会调用set函数且会收到修改值 set(value)&#123; console.log(&#x27;修改age&#x27;) number = value &#125; &#125;) console.log(person) console.log(Object.keys(person))&lt;/script&gt;&lt;/html&gt; 6.事件6.1事件处理 使用v-on:xxx或@xxx绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，都是被Vue管理的函数，this的指向是vm或组件实例对象 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;showInfo(123)&quot;&gt;按钮1&lt;/button&gt; &lt;button v-on:click=&quot;showInfo2(123,$event)&quot;&gt;按钮2&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; name:&quot;你好&quot; &#125;, methods: &#123; showInfo(number)&#123; console.log(number); &#125;, showInfo2(number,event)&#123; console.log(number,event) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 6.2事件修饰符 prevent：阻止默认事件 stop：阻止事件冒泡 once：事件只触发一次 capture：使用事件的捕获模式 self：只有event.target是当前操作的元素时才触发事件 passive：事件的默认行为立即执行，无需等待事件回调执行完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;style&gt; .demo&#123; background: red; &#125; .demo1&#123; margin-top: 20px; margin-bottom: 20px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;!-- 阻止默认事件 --&gt; &lt;a href=&quot;https://www.baidu.com/&quot; @click.prevent=&quot;func1&quot;&gt;阻止默认事件&lt;/a&gt; &lt;!-- 阻止事件冒泡 --&gt; &lt;div class=&quot;demo&quot; @click=&quot;func2&quot;&gt; &lt;button class=&quot;demo1&quot; @click.stop=&quot;func2&quot;&gt;阻止事件冒泡&lt;/button&gt; &lt;/div&gt; &lt;!-- 事件只触发一次 --&gt; &lt;button @click.once=&quot;func3&quot;&gt;事件只触发一次&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; name:&quot;你好&quot; &#125;, methods: &#123; func1()&#123; alert(&#x27;阻止默认事件&#x27;); &#125;, func2()&#123; alert(&#x27;阻止事件冒泡&#x27;); &#125;, func3()&#123; alert(&#x27;事件只触发一次&#x27;); &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 6.3键盘事件1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup=&quot;showInfo&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&quot;你好&quot; &#125;, methods: &#123; showInfo(event)&#123; if(event.keyCode == 13)&#123; console.log(event.target.value) &#125; &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 7.计算属性 要用的属性不存在，需要通过计算已有的属性得到 底层通过Object.defineProperty()实现 与methods实现相比，内部有缓存机制，效率更高 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;姓&quot; v-model:value=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;名&quot; v-model:value=&quot;lastName&quot;&gt; &lt;p&gt;全名:&#123;&#123;fullName&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;func&quot;&gt;点我修改全名&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; firstName:&#x27;&#x27;, lastName:&#x27;&#x27; &#125;, methods: &#123; func()&#123; this.fullName = &#x27;j-zn&#x27;; &#125; &#125;, computed:&#123; fullName:&#123; get()&#123; return this.firstName+this.lastName; &#125;, set(value)&#123; console.log(value); var arr = value.split(&#x27;-&#x27;); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; // 简写 // fullName()&#123; // return this.firstName+this.lastName; // &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 8.监视属性 当被监视的属性变化时，回调函数自动调用 监视属性必须存在，才能进行监视 监视的两种写法：(1)new Vue时传入watch配置(2)$watch监视 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;change&quot;&gt;点我切换天气&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; isHot:true &#125;, methods: &#123; change()&#123; this.isHot = !this.isHot; &#125; &#125;, computed:&#123; info()&#123; return this.isHot?&#x27;炎热&#x27;:&#x27;凉爽&#x27;; &#125; &#125;, watch:&#123; isHot:&#123; // immediate:true,// 初始化的时候调用一次handler // deep:true,// 深度监视 handler(newValue,oldValue)&#123; console.log(&#x27;isHot&#x27;,newValue,oldValue); &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 9.深度监视123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;a:&#123;&#123;numbers.a&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;add&quot;&gt;点我a++&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; numbers:&#123; a:0, b:1 &#125; &#125;, methods: &#123; add()&#123; this.numbers.a++; &#125; &#125;, watch:&#123; numbers:&#123; deep:true, handler(newValue,oldValue)&#123; console.log(&#x27;numbers&#x27;,newValue,oldValue); &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 10.绑定class123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;style&gt; .class1 &#123; width: 300px; height: 300px; background: red; &#125; .class2 &#123; width: 300px; height: 300px; background: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;root&quot; :class=&quot;str&quot; @click=&quot;change&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; str:&quot;class1&quot; &#125;, methods: &#123; change()&#123; this.str = this.str==&#x27;class1&#x27;? &#x27;class2&#x27;:&#x27;class1&#x27;; &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 11.条件渲染v-if 适用于切换频率较低的场景，不展示的DOM元素会被直接移除 v-if,v-else-if,v-else一起使用时结构不能被打断 v-show 适用于切换频率较高的场景 不展示的DOM不会被移除，使用样式display:none隐藏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1 v-if=&quot;n==0&quot;&gt;0&lt;/h1&gt; &lt;h1 v-else-if=&quot;n==1&quot;&gt;1&lt;/h1&gt; &lt;h1 v-else&gt;2&lt;/h1&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;show&lt;/h1&gt; &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt; &lt;button @click=&quot;show&quot;&gt;show&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; //el用于指定容器，容器和vue实例的关系的一一对应 el:&quot;#root&quot;, //存储数据 data:&#123; n:0, isShow:true &#125;, methods: &#123; change()&#123; this.n++; if(this.n&gt;=3)&#123; this.n=0; &#125; &#125;, show()&#123; this.isShow = !this.isShow; &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 12.列表渲染v-for中的key就可以是index，但最好是被遍历对象的唯一标识 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 遍历数组 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) of persons&quot; :key=&quot;person.id&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;person.id&#125;&#125;-&#123;&#123;person.name&#125;&#125;-&#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 遍历对象 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,key) of lrc&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; persons:[ &#123;id:1,name:&#x27;zhangsan&#x27;,age:20&#125;, &#123;id:2,name:&#x27;lrc&#x27;,age:22&#125;, &#123;id:3,name:&#x27;ryh&#x27;,age:21&#125;, ], lrc:&#123; id:0, name:&#x27;黎汝聪&#x27;, age:20, &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 13.列表过滤当一个对象为计算属性时。在其方法中,使用的变量发生改变了,就会触发这个计算函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;人员列表&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;keyWord&quot;&gt; &lt;!-- 遍历数组 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) of filterPersons&quot; :key=&quot;person.id&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;person.id&#125;&#125;-&#123;&#123;person.name&#125;&#125;-&#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; keyWord:&#x27;&#x27;, persons:[ &#123;id:1,name:&#x27;张三&#x27;,age:20&#125;, &#123;id:2,name:&#x27;李四&#x27;,age:22&#125;, &#123;id:3,name:&#x27;王四&#x27;,age:21&#125;, &#123;id:4,name:&#x27;张五&#x27;,age:22&#125;, &#123;id:5,name:&#x27;王五&#x27;,age:21&#125;, ], &#125;, computed:&#123; filterPersons()&#123; return this.persons.filter((p)=&gt;&#123; return p.name.indexOf(this.keyWord) !=-1; &#125;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 14.更新(Vue.set())Vue通过setter实现监控，且要在new Vue()时就传入要监测的数据 对象创建后追加的属性，默认不做响应式处理 如需给后添加的属性做响应式，可用Vue.set() Vue.set(target,propertyName&#x2F;index,value) vm.$set(target,propertyName&#x2F;index,value) 在Vue修改数组中的元素一定要用如下方法 push()，pop()，unshift()，shift()，splice()，sort()，reverse()这几个方法被Vue重写了 Vue.set和vm.$set不能给vm或vm的根数据(data)添加属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;人员列表&lt;/h1&gt; &lt;button @click.once=&quot;change&quot;&gt;修改&lt;/button&gt; &lt;!-- 遍历数组 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) of persons&quot; :key=&quot;person.id&quot;&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;person.id&#125;&#125;-&#123;&#123;person.name&#125;&#125;-&#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false //创建vue实例 const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; persons:[ &#123;id:1,name:&#x27;张三&#x27;,age:20&#125;, &#123;id:2,name:&#x27;李四&#x27;,age:22&#125;, &#123;id:3,name:&#x27;王四&#x27;,age:21&#125;, &#123;id:4,name:&#x27;张五&#x27;,age:22&#125;, &#123;id:5,name:&#x27;王五&#x27;,age:21&#125;, ], &#125;, methods: &#123; change()&#123; // this.persons[0] = &#123;id:1,name:&#x27;zhangsan&#x27;,age:20&#125;; // 无效 this.$set(this.persons,0,&#123;id:1,name:&#x27;zhangsan&#x27;,age:20&#125;) this.persons.push(&#123;id:6,name:&#x27;zhangsan&#x27;,age:20&#125;) &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 15.收集表单数据v-model默认收集value值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;form&gt; 帐号：&lt;input type=&quot;text&quot; v-model=&quot;userInfo.account&quot;&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; v-model=&quot;userInfo.sex&quot;&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; v-model=&quot;userInfo.sex&quot;&gt; &lt;br/&gt; 爱好： 学习&lt;input type=&quot;checkbox&quot; value=&quot;study&quot; v-model=&quot;userInfo.hobby&quot;&gt; 打游戏&lt;input type=&quot;checkbox&quot; value=&quot;game&quot; v-model=&quot;userInfo.hobby&quot;&gt; 吃饭&lt;input type=&quot;checkbox&quot; value=&quot;eat&quot; v-model=&quot;userInfo.hobby&quot;&gt; &lt;br/&gt; 地址： &lt;select v-model=&quot;userInfo.address&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;jdz&quot;&gt;景德镇&lt;/option&gt; &lt;option value=&quot;xian&quot;&gt;西安&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;button @click.prevent=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //阻止生成生产提示 Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; userInfo:&#123; account:&#x27;&#x27;, password:&#x27;&#x27;, sex:&#x27;&#x27;, hobby:[], address:&#x27;&#x27;, &#125; &#125;, methods: &#123; submit()&#123; console.log(this.userInfo); &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 16.Vue内置指令之前用过的指令 v-bind 单向绑定解析表达式，可简写为: v-model 双向数据绑定 v-for 遍历数组 &#x2F; 对象 &#x2F; 字符串 v-on 绑定事件监听，可简写为@ v-show 条件渲染 (动态控制节点是否展示) v-if 条件渲染（动态控制节点是否存存在） v-else-if 条件渲染（动态控制节点是否存存在） v-else 条件渲染（动态控制节点是否存存在） 16.1v-text向其所在的节点中渲染文本内容，会替换节点中的内容 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1 v-text=&quot;name&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&quot;你好&quot; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 16.2v-htmlv-html会替换掉节点中所有的内容，可以识别html结构 在网站上动态渲染任意html是非常危险的，容易导致 XSS 攻击，不要用在用户提交的内容上 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1 v-html=&quot;str&quot;&gt;hello&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; str:&quot;&lt;a href=&#x27;https://www.baidu.com/&#x27;&gt;百度&lt;/a&gt;&quot; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 16.3v-cloak本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 当网速过慢的时候不让未经解析的模板展示 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;style&gt; [v-cloak] &#123; display:none; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&#x27;你好&#x27; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 16.4v-oncev-once所在节点在初次动态渲染后，就视为静态内容了，之后数据改变不会更新 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;style&gt; [v-cloak] &#123; display:none; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 v-once&gt;初始化的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;h2&gt;当前的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; n:1 &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 16.5v-pre跳过v-pre所在节点的编译过程 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;style&gt; [v-cloak] &#123; display:none; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 v-pre&gt;当前的n值是: &#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; n:1 &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 17.生命周期 Vue在关键时刻帮我们调用的一些特殊名称的函数，又名生命周期回调函数、生命周期函数、生命周期钩子 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 生命周期函数中的 this 指向是vm或组件实例对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2 :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue&lt;/h2&gt; &lt;button @click=&quot;stop&quot;&gt;点我停止变换&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el: &#x27;#root&#x27;, data: &#123; opacity: 1 &#125;, methods: &#123; stop() &#123; this.$destroy() &#125; &#125;, // 数据代理还未开始，无法访问data和methods beforeCreate() &#123; console.log(&#x27;beforeCreate&#x27;); &#125;, // 可以访问data和methods created() &#123; console.log(&#x27;created&#x27;); &#125;, // 页面呈现的是未经Vue编译的DOM结构，此时对DOM的操作最终都不会奏效 beforeMount() &#123; console.log(&#x27;beforeMount&#x27;); &#125;, // Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted() &#123; console.log(&#x27;mounted&#x27;) this.timer = setInterval(() =&gt; &#123; this.opacity -= 0.01 if (this.opacity &lt;= 0) &#123; this.opacity = 1 &#125; &#125;, 16) &#125;, // 此时数据是新的，但页面是旧的 beforeUpdate() &#123; console.log(&#x27;beforeUpdate&#x27;); &#125;, // 此时数据和页面都是新的 updated() &#123; console.log(&#x27;updated&#x27;); &#125;, // 马上执行销毁过程，data、methods，指令等均可用，此时一般执行关闭定时器，取消订阅消息等操作 beforeDestroy() &#123; console.log(&#x27;beforeDestroy&#x27;); clearInterval(this.timer); &#125;, destroyed() &#123; console.log(&#x27;destroyed&#x27;) &#125;,&#125;)&lt;/script&gt;&lt;/html&gt; 18.组件组件名 一个单词组成 第一种写法（首字母小写）：school 第二种写法（首字母大写）：School 多个单词组成 第一种写法（kebab-case 命名）：my-school 第二种写法（CamelCase 命名）：MySchool（需要Vue脚手架支持） 可以使用name配置项指定组件在开发者工具中呈现的名字。 ​ 组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，而是 Vue.extend() 生成的。Vue 解析时会帮我们创建组件的实例对象，即Vue帮我们执行的new VueComponent(options)。每次调用Vue.extend，返回的都是一个全新的VueComponent，即不同组件是不同的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;1.html&lt;/title&gt; &lt;!-- 引入vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;school&gt;&lt;/school&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; // 定义组件 const school = Vue.extend(&#123; template:` &lt;div&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;show&quot;&gt;show&lt;/button&gt; &lt;/div&gt;`, data()&#123; return&#123; name:&#x27;景德镇一中&#x27;, address:&#x27;新厂&#x27;, &#125; &#125;, methods: &#123; show()&#123; alert(this.name); &#125; &#125;, &#125;); const student = Vue.extend(&#123; template:` &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;/div&gt;`, data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21, &#125; &#125; &#125;); // 全局注册组件 Vue.component(&#x27;school&#x27;,school); const x = new Vue(&#123; el:&quot;#root&quot;, data:&#123; name:&quot;你好&quot; &#125;, // 注册组件 components:&#123; student &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 19.脚手架使用命令 1vue create projectName 脚手架文件结构 1234567891011121314151617.文件目录├── node_modules ├── public│ ├── favicon.ico: 页签图标│ └── index.html: 主页面├── src│ ├── assets: 存放静态资源│ │ └── logo.png│ │── component: 存放组件│ │ └── HelloWorld.vue│ │── App.vue: 汇总所有组件│ └── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件└── package-lock.json: 包版本控制文件 组件在脚手架中的使用 School.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;show&quot;&gt;show&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; name:&#x27;景德镇一中&#x27;, address:&#x27;新厂&#x27;, &#125; &#125;, methods: &#123; show()&#123; alert(this.name); &#125; &#125;&#125;&lt;/script&gt; Student.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21, &#125; &#125;&#125;&lt;/script&gt; App.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import School from &#x27;./components/School.vue&#x27;;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; School, Student &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 20.render函数import Vue from ‘vue’引入的是dist&#x2F;vue.runtime.esm.js，只包含核心功能，没有模板解析器。因为vue.runtime.esm.js没有模板解析器，所以要使用render函数接收到的createElement函数去指定具体内容。 12345render: h =&gt; h(App)// 完整形式render(createElement)&#123; return createElement(App);&#125; 21.vue.config.js配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* 引入打包分析插件 */const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;/* 引入压缩插件 但是导致项目启动的比较慢*/const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;);let isProduction = process.env.NODE_ENV === &#x27;production&#x27;; // 判断是否是生产环境let isTest = process.env.NODE_ENV === &#x27;test&#x27;; // 判断是否是测试环境const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)function resolve(dir) &#123; return path.join(__dirname, dir)&#125;// 服务端ip -- Uat环境const api = &#x27;http://10.1.12.181:26341&#x27;;module.exports = &#123; /* 打包后的文件夹名字及路径 根目录下 */ outputDir: &#x27;video&#x27;, /* 生产的项目名 可以用三元运算符*/ publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/video/&#x27; : &#x27;/videoDev/&#x27;, /* 保存时是否校验 */ lintOnSave: false, /* 开发环境跨域情况的代理配置 */ devServer: &#123; // https: true, // 链接是否使用https访问 但可能在微信中不能打开（安全性问题） 不写此行配置默认 使用http协议打开 port: &#x27;31001&#x27;, // 指定要监听请求的端口号 open: true, // 是否运行好直接在默认浏览器打开 inline: true, // 用于设置代码保存时是否自动刷新页面。 hot: true, // 用于设置代码保存时是否进行热更新（局部刷新，不刷新整个页面） disableHostCheck: true, //可以被外网访问 /* 当出现编译器错误或警告时，在浏览器中显示全屏覆盖层。默认禁用。两种写法*/ // overlay: true, // 第一种 overlay: &#123; //第二种 warnings: false, //是否警告 errors: false, &#125;, /* 接口代理器设置 可以配置多个*/ proxy: &#123; &#x27;/backend&#x27;: &#123; // 实际访问的服务器地址 target: api, // 控制服务器收到的请求头中Host字段的值 host就是主机名加端口号 实际上就是欺骗后端服务器 changeOrigin: true, // 是否启用websockets ws: false, // 重写请求路径 开头是/api的替换为 空串 pathRewrite: &#123; &#x27;/api&#x27;: &#x27;&#x27; &#125;, &#125;, &#125;, &#125;, /* css相关设置 */ css: &#123; extract: false, // 是否使用css分离插件 ExtractTextPlugin 开启extract后，组件样式以内部样式表的形式加载的, 打包的结果会多出一个 css 文件夹以及css 文件。 sourceMap: true, // 开启 CSS source maps? /* 向所有 Sass/Less 样式传入共享的全局变量 */ loaderOptions: &#123; //注意：在 sass-loader v8 中，这个选项名是 &quot;prependData&quot; global.scss这里面定义的是一些全局变量 scss: &#123; prependData: &#x27;@import &quot;~@/assets/scss/global.scss&quot;;&#x27;, &#125;, &#125;, &#125;, /* webpack相关配置 *该对象将会被 webpack-merge 合并入最终的 webpack 配置 */ configureWebpack: (config) =&gt; &#123; // 为生产环境修改配置... if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; // 打包可视化分析 config.plugins.push(new BundleAnalyzerPlugin()); /* js 压缩 */ config.plugins.push(new UglifyJsPlugin(&#123; uglifyOptions: &#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, drop_console: true // 生产环境自动删除console &#125;, warnings: false &#125;, sourceMap: false, parallel: true // 使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1。 &#125; &#125;)) &#125; else &#123; // 为开发环境修改配置... &#125; &#125;, /* 对内部的 webpack 配置（比如修改、增加Loader选项）(链式操作) */ chainWebpack: (config) =&gt; &#123; //添加别名 config.resolve.alias .set(&#x27;@&#x27;, resolve(&#x27;src&#x27;)) .set(&#x27;assets&#x27;, resolve(&#x27;src/assets&#x27;)) .set(&#x27;components&#x27;, resolve(&#x27;src/components&#x27;)) .set(&#x27;layout&#x27;, resolve(&#x27;src/layout&#x27;)) .set(&#x27;base&#x27;, resolve(&#x27;src/base&#x27;)) .set(&#x27;static&#x27;, resolve(&#x27;src/static&#x27;)); // 压缩图片 config.module .rule(&#x27;images&#x27;) /* 需要下载这个图片压缩loader cnpm install --save-dev image-webpack-loader */ .use(&#x27;image-webpack-loader&#x27;) .loader(&#x27;image-webpack-loader&#x27;) .options(&#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, optipng: &#123; enabled: false &#125;, pngquant: &#123; quality: [0.8,0.9], speed: 4 &#125;, gifsicle: &#123; interlaced: false &#125;, webp: &#123; quality: 75 &#125;, &#125;); &#125;, /* 第三方插件配置 */ pluginOptions: &#123; &#x27;process.env&#x27;: &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;, &#125;, // 我这里用的是 vue-cli-plugin-mock 插件；用来开发前期模拟后端的请求 // debug 为true时 vscode的控制台会打印接口日志 mock: &#123; entry: &#x27;./mock/index.js&#x27;, debug: true &#125;, &#125;,&#125;; 22.ref类似于id，应用在html标签上获取的是真实DOM元素，应用在组件上获取的是组件实例对象 获取组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Student ref=&quot;student&quot;&gt;&lt;/Student&gt; &lt;button @click=&quot;show&quot;&gt;打印组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;, methods:&#123; show()&#123; console.log(this.$refs.student); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 获取真实DOM 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1 ref=&quot;name&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;show&quot;&gt;打印DOM&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21, &#125; &#125;, methods:&#123; show()&#123; console.log(this.$refs.name); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 23.props让组件接收外部传过来的数据 props是只读的，且优先级高于data 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age+1&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; &#125; &#125;, // 简单接收 // props:[&#x27;name&#x27;,&#x27;age&#x27;], // 限制类型 // props:&#123; // name:String, // age:Number // &#125;, // 限制类型、必要性、默认值 props:&#123; name:&#123; type:String, require:true, default:&#x27;less&#x27; &#125;, age:&#123; type:Number, require:false, default:99 &#125; &#125;&#125;&lt;/script&gt; 传参 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Student name=&quot;黎汝聪&quot; :age=&quot;18&quot;&gt;&lt;/Student&gt; &lt;Student name=&quot;菜妈&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; Student &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 24.本地存储存储内容大小一般支持 5MB 左右，浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。 xxxStorage.setItem(‘key’, ‘value’)该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值 xxxStorage.getItem(‘key’)该方法接受一个键名作为参数，返回键名对应的值 xxxStorage.removeItem(‘key’)该方法接受一个键名作为参数，并把该键名从存储中删除 xxxStorage.clear()该方法会清空存储中的所有数据 SessionStorage存储的内容会随着浏览器窗口关闭而消失 LocalStorage存储的内容，需要手动清除才会消失 xxxStorage.getItem(xxx)如果 xxx 对应的 value 获取不到，那么getItem()的返回值是null 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;localStorage&lt;/h2&gt; &lt;button onclick=&quot;saveDate()&quot;&gt;点我保存数据&lt;/button&gt;&lt;br/&gt; &lt;button onclick=&quot;readDate()&quot;&gt;点我读数据&lt;/button&gt;&lt;br/&gt; &lt;button onclick=&quot;deleteDate()&quot;&gt;点我删除数据&lt;/button&gt;&lt;br/&gt; &lt;button onclick=&quot;deleteAllDate()&quot;&gt;点我清空数据&lt;/button&gt;&lt;br/&gt;&lt;/body&gt;&lt;script&gt; let person = &#123;name:&quot;黎汝聪&quot;,age:20&#125; function saveDate()&#123; localStorage.setItem(&#x27;msg&#x27;,&#x27;localStorage&#x27;) localStorage.setItem(&#x27;person&#x27;,JSON.stringify(person)) &#125; function readDate()&#123; console.log(localStorage.getItem(&#x27;msg&#x27;)) const person = localStorage.getItem(&#x27;person&#x27;) console.log(JSON.parse(person)) &#125; function deleteDate()&#123; localStorage.removeItem(&#x27;msg&#x27;) localStorage.removeItem(&#x27;person&#x27;) &#125; function deleteAllDate()&#123; localStorage.clear() &#125;&lt;/script&gt;&lt;/html&gt; 25.自定义事件一种组件间通信方式，适用于子组件传参数给父组件 第一种方式，在父组件中&lt;Child @事件名&#x3D;”方法”&#x2F;&gt;或&lt;Demo v-on:事件名&#x3D;”回调方法”&#x2F;&gt; 第二种方式，在父组件中this.$refs.demo.$on(‘事件名’,回调方法) 触发自定义事件this.$emit(‘事件名’,数据) 解绑自定义事件this.$off(‘事件名’) 注意：通过this.$refs.xxx.$on(‘事件名’,回调函数)绑定自定义事件时，回调函数要么配置在methods中，要么用箭头函数，否则 this 指向会出问题 App.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过给子组件绑定一个自定义事件实现子组件给父组件传参 --&gt; &lt;Student @send=&quot;printStudentName&quot;&gt;&lt;/Student&gt; &lt;!-- 通过ref绑定自定义事件实现子组件给父组件传参 --&gt; &lt;Student ref=&quot;student&quot;&gt;&lt;/Student&gt; &lt;!-- 通过props传函数参数的方式实现子组件给父组件传参 --&gt; &lt;School :printSchoolName=&#x27;printSchoolName&#x27;&gt;&lt;/School&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student.vue&#x27;;import School from &#x27;./components/School.vue&#x27;;export default &#123; name: &#x27;App&#x27;, components: &#123; Student, School &#125;, methods:&#123; printSchoolName(name)&#123; console.log(&#x27;Apps收到了schoolName:&#x27;+name); &#125;, printStudentName(name)&#123; console.log(&#x27;Apps收到了studentName:&#x27;+name); &#125; &#125;, mounted()&#123; // 绑定send事件和对应的回调函数 this.$refs.student.$on(&#x27;send&#x27;,this.printStudentName); &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Student.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;send&quot;&gt;send学生名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21 &#125; &#125;, methods:&#123; send()&#123; // 触发Student实例身上的send事件 this.$emit(&quot;send&quot;,this.name); &#125; &#125;&#125;&lt;/script&gt; School.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;send&quot;&gt;send学校名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; name:&#x27;景德镇一中&#x27;, address:&#x27;新厂&#x27;, &#125; &#125;, methods: &#123; send()&#123; this.printSchoolName(this.name); &#125; &#125;, props:[&#x27;printSchoolName&#x27;]&#125;&lt;/script&gt; 26.全局事件总线一种可以在任意组件间通信的方式，本质上就是一个对象，它必须满足以下条件 所有的组件对象都必须能看见他 这个对象必须能够使用$on$emit$off方法去绑定、触发和解绑事件 main.js 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render(createElement)&#123; return createElement(App); &#125;, beforeCreate()&#123; // 安装全局事件总线，$bus就是当前应用的vm Vue.prototype.$bus = this &#125;&#125;).$mount(&#x27;#app&#x27;) Student.vue(发送消息的组件) 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;send&quot;&gt;send学生名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21 &#125; &#125;, methods:&#123; send()&#123; // 触发事件 this.$bus.$emit(&#x27;getStudentName&#x27;,this.name); &#125; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt; School.vue(接收消息的组件) 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; name:&#x27;景德镇一中&#x27;, address:&#x27;新厂&#x27;, &#125; &#125;, methods: &#123; printStudentName(name)&#123; console.log(&#x27;studentName:&#x27;,name); &#125; &#125;, mounted()&#123; // 绑定事件，接收学生名 this.$bus.$on(&#x27;getStudentName&#x27;,this.printStudentName); &#125;, beforeDestroy()&#123; // 销毁前解绑事件 this.$bus.$off(&#x27;getStudentName&#x27;); &#125;&#125;&lt;/script&gt; 27.消息订阅和发布的使用一种可以在任意组件间通信的方式 安装pubsub-js 1npm i pubsub-js Student.vue(发布消息的组件) 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;send&quot;&gt;发布学生名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;export default &#123; data()&#123; return&#123; name:&#x27;黎汝聪&#x27;, age:21 &#125; &#125;, methods:&#123; send()&#123; // 发布消息 pubsub.publish(&#x27;getStudentName&#x27;,this.name); &#125; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt; School.vue(接收消息的组件) 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;export default &#123; data()&#123; return &#123; name:&#x27;景德镇一中&#x27;, address:&#x27;新厂&#x27;, pubId:0 &#125; &#125;, methods: &#123; printStudentName(messageName,name)&#123; console.log(&#x27;有人发布了消息&#x27;); console.log(&#x27;messageId:&#x27;,this.pubId); console.log(&#x27;messageName:&#x27;,messageName); console.log(&#x27;studentName:&#x27;,name); &#125; &#125;, mounted()&#123; // 订阅消息 this.pubId = pubsub.subscribe(&#x27;getStudentName&#x27;,this.printStudentName); &#125;, beforeDestroy()&#123; // 取消订阅 pubsub.unsubscribe(this.pubId); &#125;&#125;&lt;/script&gt; 28.$nextTick 这是一个生命周期钩子,this.$nextTick(回调函数)在下一次DOM更新结束后执行其指定的回调 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;Student/&gt; &lt;School/&gt; --&gt; &lt;h1&gt;&#123;&#123;n&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;add&quot;&gt;n++&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; n:1 &#125; &#125;, methods:&#123; add()&#123; if(this.n&lt;5)&#123; this.$nextTick(()=&gt;&#123; console.log(&#x27;update&#x27;,this.n); &#125;); &#125; this.n++; &#125; &#125;&#125;&lt;/script&gt; 29.配置代理vue.config.js 1234567891011121314151617181920const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, // 关闭语法检查 lintOnSave:false, publicPath:&#x27;./&#x27;, devServer: &#123; port: 8080, // proxy:&#x27;http://127.0.0.1:8001&#x27;, proxy:&#123; &#x27;/proxy&#x27;:&#123; target:&#x27;http://127.0.0.1:8001&#x27;, pathRewrite:&#123;&#x27;/proxy&#x27;:&#x27;/proxy&#x27;&#125;, // ws: true, //用于支持websocket,默认值为true // changeOrigin: true //用于控制请求头中的host值,默认值为true,服务器收到的请求头中的host值为target中的值 &#125; &#125;&#125;,&#125;) App.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;get1&quot;&gt;获取1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; get1()&#123; axios.get(&#x27;http://localhost:8080/proxy/&#x27;).then(response =&gt;&#123; console.log(response.data); &#125;,error=&gt;&#123; console.log(error.message); &#125;) &#125; &#125;, components: &#123; &#125;&#125;&lt;/script&gt; nodejs 1234567891011121314151617181920const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const bodyParser = require(&quot;body-parser&quot;);//创建web服务器let app = express();// app.use(cors());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());const port = 8001;//设置监听端口和启动成功回调函数app.listen(port, () =&gt; &#123; console.log(&#x27;run at http://127.0.0.1:&#x27; + port);&#125;);//托管静态资源.可以访问public目录中的所有文件，路径中不含publicapp.get(&quot;/proxy&quot;, function(req, res) &#123; //在命令行中查看传递过来的参数 console.log(&#x27;1&#x27;); res.send(&quot;proxyTest&quot;);&#125;); 30.插槽让父组件向子组件中的指定位置插入html结构 30.1默认插槽App.vue(父组件) 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;Test&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;/Test&gt; &lt;Test&gt; &lt;button @click=&quot;show&quot;&gt;点击弹窗&lt;/button&gt; &lt;/Test&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Test from &#x27;./components/Test.vue&#x27;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; show()&#123; alert(&#x27;hello!&#x27;); &#125; &#125;, components: &#123; Test &#125;&#125;&lt;/script&gt; Test.vue(子组件) 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;span&gt;哈哈&lt;/span&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; isShow:true &#125; &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1&#123; background-color: orange;&#125;&lt;/style&gt; 30.2具名插槽使用name指定填入的插槽 App.vue(父组件) 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;Test&gt; &lt;h1 slot=&quot;center&quot;&gt;你好&lt;/h1&gt; &lt;a href=&quot;https://www.baidu.com/&quot; slot=&quot;footer&quot;&gt;百度&lt;/a&gt; &lt;/Test&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Test from &#x27;./components/Test.vue&#x27;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; show()&#123; alert(&#x27;hello!&#x27;); &#125; &#125;, components: &#123; Test &#125;&#125;&lt;/script&gt; Test.vue(子组件) 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;span&gt;哈哈&lt;/span&gt; &lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; isShow:true &#125; &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1&#123; background-color: orange;&#125;&lt;/style&gt; 30.3作用域插槽将插槽所在组件的数据传给插槽使用者 App.vue(父组件) 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;Test&gt; &lt;template slot-scope=&quot;data&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(student,index) of data.students&quot; :key=&quot;index&quot;&gt;&#123;&#123;student&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Test&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Test from &#x27;./components/Test.vue&#x27;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;, components: &#123; Test &#125;&#125;&lt;/script&gt; Test.vue(子组件) 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;slot :students=&quot;students&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; students:[&#x27;黎汝聪&#x27;,&#x27;刘人恺&#x27;,&#x27;饶以恒&#x27;,&#x27;饶伟&#x27;] &#125; &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1&#123; background-color: orange;&#125;&lt;/style&gt; 31.Vuex专门在Vuez实现集中式数据管理的一个Vue插件 安装vuex vue2只能用vuex的3版本，vue3中只能用vuex的4版本 1npm install vuex@3 使用vuex main.js 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store/index&#x27;Vue.config.productionTip = falsenew Vue(&#123; store:store, render(createElement)&#123; return createElement(App); &#125;&#125;).$mount(&#x27;#app&#x27;) 创建store&#x2F;index.js 123456789101112131415161718192021// 该文件用于创建Vuexz最为核心的storeimport Vue from &#x27;vue&#x27;// 引入vueximport Vuex from &#x27;vuex&#x27;Vue.use(Vuex);// 用于响应组件中的动作const actions = &#123;&#125;// 用于操作数据const mutations = &#123;&#125;// 用于存储数据const state = &#123;&#125;// 创建storeconst store = new Vuex.Store(&#123; actions:actions, mutations:mutations, state:state&#125;)export default store App.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;$store.state.number&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;sub&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Test from &#x27;./components/Test.vue&#x27;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; add()&#123; this.$store.dispatch(&#x27;add&#x27;,1); &#125;, sub()&#123; this.$store.commit(&#x27;SUB&#x27;,1); &#125; &#125;, mounted()&#123; console.log(this.$store) &#125;&#125;&lt;/script&gt; 32.路由路由即一组映射关系，key为路径,value可能是function或component 安装 vue-router4只能在vue3中使用，vue-router3才能在vue2中使用 1npm i vue-router@3 32.1基本使用编写路由配置，src&#x2F;router&#x2F;index.js 12345678910111213141516171819202122232425262728293031// 该文件用于创建整个项目的路由import VueRouter from &#x27;vue-router&#x27;import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;import News from &#x27;../components/News&#x27;import Message from &#x27;../components/Message&#x27;export default new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/Home&#x27;, component:Home, // 多级路由 children: [ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; path:&#x27;message&#x27;, component:Message &#125; ], &#125; ]&#125;) main.js 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;Vue.use(VueRouter)Vue.config.productionTip = falsenew Vue(&#123; render(createElement)&#123; return createElement(App); &#125;, router:router&#125;).$mount(&#x27;#app&#x27;) App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div&gt; &lt;h1&gt;Vue router demo&lt;/h1&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; &lt;router-link to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- 指定组件的呈现位置 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.clearfix::before,.clearfix::after &#123; content: &quot;&quot;; display: table; clear: both;&#125;.right&#123; float: left; margin-left: 20px;&#125;.left&#123; float: left; border: #A3A4A3 1px solid; padding: 0;&#125;.left &gt; a&#123; display: block; text-decoration:none; padding-top: 20px; padding-bottom: 20px; padding-left: 50px; padding-right: 50px;&#125;.left &gt; a:hover,.active&#123; background: #2471BA; color: #FFFFFF;&#125;&lt;/style&gt; About.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(student,index) of students&quot; :key=&quot;index&quot;&gt;&#123;&#123;student&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; students:[&#x27;黎汝聪&#x27;,&#x27;刘人恺&#x27;,&#x27;饶以恒&#x27;,&#x27;饶伟炎&#x27;] &#125; &#125;, methods:&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1&#123; background-color: orange;&#125;&lt;/style&gt; Home.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;h1&gt;I&#x27;m Home!!!&lt;/h1&gt; &lt;router-link to=&quot;/home/news&quot; active-class=&quot;active&quot;&gt;News&lt;/router-link&gt; &lt;router-link to=&quot;/home/message&quot; active-class=&quot;active&quot;&gt;Message&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;a&#123; display: inline-block; text-decoration:none; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 20px;&#125;a:hover,.active&#123; background: #2471BA; color: #FFFFFF;&#125;&lt;/style&gt; News.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;news001&lt;/li&gt; &lt;li&gt;news002&lt;/li&gt; &lt;li&gt;news003&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt; Message.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;message001&lt;/li&gt; &lt;li&gt;message002&lt;/li&gt; &lt;li&gt;message003&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt; 32.2注意事项 通过切换“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载 每个组件都有自己的$route属性，里面存储着自己的路由信息 整个应用只有一个router，可以通过组件的$router属性获 32.3跳转传参32.3.1query传参App.vue(父组件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div&gt; &lt;h1&gt;Vue router demo&lt;/h1&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;!-- 路由跳转 --&gt; &lt;router-link :to=&quot;&#123; path:&#x27;/about&#x27;, query:&#123; data:queryData &#125;, &#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; &lt;router-link to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- 指定组件的呈现位置 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; queryData:&#x27;query参数&#x27;, &#125; &#125;, methods:&#123; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.clearfix::before,.clearfix::after &#123; content: &quot;&quot;; display: table; clear: both;&#125;.right&#123; float: left; margin-left: 20px;&#125;.left&#123; float: left; border: #A3A4A3 1px solid; padding: 0;&#125;.left &gt; a&#123; display: block; text-decoration:none; padding-top: 20px; padding-bottom: 20px; padding-left: 50px; padding-right: 50px;&#125;.left &gt; a:hover,.active&#123; background: #2471BA; color: #FFFFFF;&#125;&lt;/style&gt; About.vue(子组件) 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;$route.query.data&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; console.log(this.$route); &#125;&#125;&lt;/script&gt; 32.3.2params传参必须使用命名路由name，并在path中给参数占位 router&#x2F;index.js 1234567891011121314// 该文件用于创建整个项目的路由import VueRouter from &#x27;vue-router&#x27;import About from &#x27;../components/About&#x27;export default new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about/:data&#x27;, component:About &#125; ]&#125;) App.vue(父组件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div&gt; &lt;h1&gt;Vue router demo&lt;/h1&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;!-- 路由跳转 --&gt; &lt;router-link :to=&quot;&#123; name:&#x27;guanyu&#x27;, params:&#123; data:paramData &#125; &#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- 指定组件的呈现位置 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; queryData:&#x27;query参数&#x27;, paramData:&#x27;params参数&#x27; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.clearfix::before,.clearfix::after &#123; content: &quot;&quot;; display: table; clear: both;&#125;.right&#123; float: left; margin-left: 20px;&#125;.left&#123; float: left; border: #A3A4A3 1px solid; padding: 0;&#125;.left &gt; a&#123; display: block; text-decoration:none; padding-top: 20px; padding-bottom: 20px; padding-left: 50px; padding-right: 50px;&#125;.left &gt; a:hover,.active&#123; background: #2471BA; color: #FFFFFF;&#125;&lt;/style&gt; About.vue(子组件) 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;$route.params.data&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; console.log(this.$route); &#125;&#125;&lt;/script&gt; 32.3.3props配置router&#x2F;index.js 12345678910111213141516171819202122232425// 该文件用于创建整个项目的路由import VueRouter from &#x27;vue-router&#x27;import About from &#x27;../components/About&#x27;export default new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about/:data&#x27;, component:About, // 第一种写法,该对象中所有的key-value会通过props传给About组件 // props:&#123;a:1,b:&#x27;lrc&#x27;&#125; // 第二种写法：props值为函数，该函数返回的对象中的key-value都会通过props传给Detail组件 // props($route)&#123; // return &#123; // id: $route.query.id, // title: $route.query.title // &#125; // &#125; // 第三种写法，props为布尔值，当为true时，路由受到的所有参数都会通过props传给About组件 props:true &#125;, ]&#125;) App.vue(父组件) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;div&gt; &lt;h1&gt;Vue router demo&lt;/h1&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;!-- 路由跳转 --&gt; &lt;router-link :to=&quot;&#123; name:&#x27;guanyu&#x27;, params:&#123; data:paramData &#125; &#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; &lt;router-link to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;!-- 指定组件的呈现位置 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; paramData:&#x27;params参数&#x27; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.clearfix::before,.clearfix::after &#123; content: &quot;&quot;; display: table; clear: both;&#125;.right&#123; float: left; margin-left: 20px;&#125;.left&#123; float: left; border: #A3A4A3 1px solid; padding: 0;&#125;.left &gt; a&#123; display: block; text-decoration:none; padding-top: 20px; padding-bottom: 20px; padding-left: 50px; padding-right: 50px;&#125;.left &gt; a:hover,.active&#123; background: #2471BA; color: #FFFFFF;&#125;&lt;/style&gt; About.vue(子组件) 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;$route.params.data&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;data&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125;, mounted()&#123; console.log(this.$route); &#125;, props:[&#x27;data&#x27;]&#125;&lt;/script&gt; 32.4replace 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：push和replace push是追加历史记录 replace是替换当前记录，路由跳转时候默认为push方式 开启replace模式 123&lt;router-link :replace=&quot;true&quot; ...&gt;News&lt;/router-link&gt;简写&lt;router-link replace ...&gt;News&lt;/router-link&gt; 总结：浏览记录本质是一个栈，默认push，点开新页面就会在栈顶追加一个地址，后退，栈顶指针向下移动，改为replace就是不追加，而将栈顶地址替换 32.5编程式路由跳转 作用：不借助实现路由跳转，让路由跳转更加灵活 this.$router.push({}) 内传的对象与中的to相同 this.$router.replace({}) this.$router.forward() 前进 this.$router.back() 后退 this.$router.go(n) 可前进也可后退，n为正数前进n，为负数后退 32.6缓存路由组件让不展示的路由不被销毁 123456789// 缓存一个路由组件&lt;keep-alive include=&quot;News&quot;&gt; // include中写想要缓存的组件名，不写表示全部缓存 &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 缓存多个路由组件&lt;keep-alive :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 32.7路由守卫32.7.1全局路由守卫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 该文件用于创建整个项目的路由import VueRouter from &#x27;vue-router&#x27;import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;import News from &#x27;../components/News&#x27;import Message from &#x27;../components/Message&#x27;const router = new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About, meta:&#123;isAuth:true,title:&#x27;关于&#x27;&#125; &#125;, &#123; path:&#x27;/Home&#x27;, component:Home, // 多级路由 children: [ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; path:&#x27;message&#x27;, component:Message &#125; ], &#125; ]&#125;)// 全局前置路由守卫，初始化的时候，每次路由切换前被调用router.beforeEach((to, from, next) =&gt; &#123; console.log(&#x27;全局前置路由守卫&#x27;) console.log(&#x27;from&#x27;,from); console.log(&#x27;to&#x27;,to) next();&#125;)// 全局前置路由守卫，初始化的时候，每次路由切换后被调用router.afterEach((to,from)=&gt;&#123; console.log(&#x27;全局后置路由守卫&#x27;) console.log(&#x27;from&#x27;,from); console.log(&#x27;to&#x27;,to) // 修改页面标题 if(to.meta.isAuth)&#123; document.title = to.meta.title; &#125;&#125;)export default router 32.7.2独享路由守卫12345678910111213141516171819202122232425262728293031323334353637383940// 该文件用于创建整个项目的路由import VueRouter from &#x27;vue-router&#x27;import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;import News from &#x27;../components/News&#x27;import Message from &#x27;../components/Message&#x27;const router = new VueRouter(&#123; routes:[ &#123; name:&#x27;guanyu&#x27;, path:&#x27;/about&#x27;, component:About, meta:&#123;isAuth:true,title:&#x27;关于&#x27;&#125; &#125;, &#123; path:&#x27;/Home&#x27;, component:Home, // 多级路由 children: [ &#123; path:&#x27;news&#x27;, component:News, beforeEnter:(to,from,next)=&gt;&#123; console.log(&#x27;News独享前置路由守卫&#x27;) console.log(&#x27;from&#x27;,from); console.log(&#x27;to&#x27;,to) next(); &#125;, &#125;, &#123; path:&#x27;message&#x27;, component:Message &#125; ], &#125; ]&#125;)export default router 32.7.3组件内路由守卫12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;news001&lt;/li&gt; &lt;li&gt;news002&lt;/li&gt; &lt;li&gt;news003&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 通过路由规则进入组件前调用 beforeRouteEnter(to,from,next)&#123; console.log(&#x27;beforeRouteEnter&#x27;); console.log(&#x27;to&#x27;,to); console.log(&#x27;from&#x27;,from) next(); &#125;, // 通过路由规则离开该组件时被调用 beforeRouteLeave(to,from,next)&#123; console.log(&#x27;beforeRouteLeave&#x27;); console.log(&#x27;to&#x27;,to); console.log(&#x27;from&#x27;,from) next(); &#125;&#125;&lt;/script&gt; 32.8路由的两种工作模式 对于一个url来说，及其后面的内容就是hash值hash值不会包含在HTTP请求中，即：hash值不会带给服务器hash模式 地址中永远带着#号，不美观 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法 兼容性较好 history模式 地址干净，美观 兼容性和hash模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题 1234567const router = new VueRouter(&#123; mode:&#x27;history&#x27;, routes:[...]&#125;)export default router","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Nginx学习随笔","slug":"nginx-note","date":"2022-11-05T06:22:41.000Z","updated":"2024-05-14T14:22:19.992Z","comments":false,"path":"nginx-note/","permalink":"http://example.com/nginx-note/","excerpt":"","text":"1.常用版本Nginx开源版 http://nginx.org/ Ngnix plus商业版 https://www.nginx.com Openresty商业版 http://openresty.org Tengine商业版 http://tengine.taobao.org/ 2.安装Nginx2.1检查环境12345678910#解压文件tar zxvf nginx-1.22.0.tar.gz#检查环境#先决定好安装路径，如 A 目录#解压压缩包到 B 目录#进入 B 目录，指定 A 目录为安装目录。即执行 ./configure --prefix=A目录#执行 make#执行 make install#进入 A 目录，Nginx 已经准备就绪./configure --prefix=/usr/local/nginx 报错信息： 1234./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre=&lt;path&gt; option. 解决方案： 12#安装perl库yum install -y pcre pcre-devel 不缺依赖的检查结果 123456789101112131415161718Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: &quot;/usr/local/nginx-1.22.0&quot; nginx binary file: &quot;/usr/local/nginx-1.22.0/sbin/nginx&quot; nginx modules path: &quot;/usr/local/nginx-1.22.0/modules&quot; nginx configuration prefix: &quot;/usr/local/nginx-1.22.0/conf&quot; nginx configuration file: &quot;/usr/local/nginx-1.22.0/conf/nginx.conf&quot; nginx pid file: &quot;/usr/local/nginx-1.22.0/logs/nginx.pid&quot; nginx error log file: &quot;/usr/local/nginx-1.22.0/logs/error.log&quot; nginx http access log file: &quot;/usr/local/nginx-1.22.0/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot; 2.2编译安装下载地址:http://nginx.org/en/download.html 1234#进入解压的目录下，编译make#安装make install 2.3验证123456789cd sbin#启动nginx./nginx#快速停止./nginx -s stop#优雅关闭，关闭之前完成已经接受的连接请求./ngnix -s quit#重新加载配置./ngnix -s reload 2.4windows下安装下载地址http://nginx.org/download/ 可解决跨域问题方便调试程序 进入解压后文件夹根目录，打开cmd 123456#启动nginxstart nginx#停止nginxnginx -s stop#重启服务nginx -s reload 解决session失效问题 123456location /api/ &#123; proxy_pass http://127.0.0.1:8080/demo/; proxy_cookie_path /demo /api;&#125;#语法#proxy_cookie_path path replacement cookie的path与地址栏的path不一致就会被浏览器丢弃造成session验证失效，加上这个配置在转发的时候会把path替换，path为要替换的路径，replacement为要替换的值 3.nginx配置文件3.1基本概念(1)正向代理 在客户端配置代理服务器，通过代理服务器进行互联网访问(屏蔽了真正的客户端) (2)反向代理 客户将请求发到代理服务器进行互联网访问，反向代理服务器和目标服务器对外是一个服务器(屏蔽了真正的服务端) (3)负载均衡 将负载均衡地发配给各个服务器 (4)动静分离 动态资源和静态资源交给不同的服务器 3.2nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#user nobody;#工作的进程个数worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; #每个worker能创建的连接数 worker_connections 1024;&#125;http &#123; #将其它文件引入，mime.types记录了请求头中的文件类型 include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; #数据零拷贝 sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; #虚拟主机 server &#123; #端口号 listen 80; #域名，主机名 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #根目录，可以放静态资源文件 root html; #默认展示的文件 index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 3.3反向代理配置vi usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 123456789101112131415161718http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; &#125; server &#123; listen 80; server_name localhost; location / &#123; #所有匹配到的请求都会被转发给http://127.0.0.1:8080/ proxy_pass http://127.0.0.1:8080/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 3.4负载均衡1234567891011121314151617181920212223http &#123; include mime.types; default_type application/octet-stream; upstream myserver &#123; server 127.0.0.1:8080; server 127.0.0.1:80; &#125; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; location /proxy/ &#123; proxy_pass http://myserver/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 分配策略 (1)轮询 默认，按顺序逐一分配 (2)weight weight代表权重，默认为1，权重越高被分配的客户端越多 1234upstream myserver &#123; server 127.0.0.1:8080 weight=10; server 127.0.0.1:80 weight=1;&#125; (3)ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session问题 12345upstream myserver &#123; ip_hash server 127.0.0.1:8080; server 127.0.0.1:80;&#125; (4)fair 按后端服务器的响应时间分配,需要第三方插件","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"}],"tags":[]},{"title":"Redis用法笔记","slug":"redis-note","date":"2022-11-05T06:22:21.000Z","updated":"2024-05-14T14:26:49.296Z","comments":false,"path":"redis-note/","permalink":"http://example.com/redis-note/","excerpt":"","text":"1.安装Redis(1)解压文件 1tar -zxvf redis-6.2.7.tar.gz (2)编译 12cd redis-6.2.7make (3)安装 1make install (4)验证 12cd /usr/local/binll 查看默认安装目录 &#x2F;usr&#x2F;local&#x2F;bin redis-benchmark：性能测试工具 redis-check-aof：修复有问题的AOF文件 redis-check-rdb：修复有问题的rdb文件 redis-sentinel：Redis集群使用 redis-server：Redis服务器启动命令 redis-cli：客户端，操作入口 (5)启动 前台启动,进入&#x2F;usr&#x2F;local&#x2F;bin目录，ctrl+C退出 1redis-server 后台启动，进入redis目录 1vi redis.conf 将daemonize no改为daemonize yes 设置密码，requirepass password 12345678910cd /usr/local/binredis-server /usr/local/redis-6.2.7/redis.conf#查看redis进程ps -ef | grep redis#通过客户端连接redis-cli#关闭redis-cli shutdown#设置密码后关闭redis-cli -a password shutdown 2.使用默认16个数据库，下标从0开始，默认使用0号库 Redis是单线程＋IO多路复用技术 123456#换库select index#查看当前数据库的key的数量dbsize#清空当前库flushdb 2.1数据类型2.1.1常用key操作12345678910111213141516#查看当前库的所有keykeys *#设置一个keyset key value#判断某个key是否存在exists key#查看某个键的类型type key#删除指定的keydel key#删除指定的key，非阻塞删除，真正的删除会在后续异步操作unlink key#给指定的key设置10秒的过期时间expire key 10#查看指定的key还有多少秒过期，-1表示永不过期，-2表示已经过期ttl key 2.1.2常用数据类型(1)string 二进制安全，value最大为512M 12345678910111213141516171819202122#获取值get key#设置值set key value#追加值append key value#获取string的长度strlen key#让存储的数字值增1，如果为空，新增值为1incr key#让存储的数字值减1decr key#增加valueincrby key value#减少valuedecrby key value#设置多个key,valuemset key1 value1 key2 value2 ...#获取多个valuemget key1 key2 ...#设置key,value的同时设置过期时间setex key time value (2)List 123456789101112131415161718#在左/右侧加入数据lpush/rpush key value1 value2 ...#在左/右侧弹出数据lpop/rpop key#从列表key1右边取一个值插入key2左边rpoplpush key1 key2#取出指定范围的值lrange key start end#按下标获取元素lindex key index#获取列表长度llen key#在value前/后面插入新值linsert key BEFORE|AFTER value newvalue#从左边删除n个valuelrem key n value#设置指定下标元素的值lset key index value (3)set 12345678910111213141516#将一个或多个元素加入刀集合key中，已经存在的元素将被忽略sadd key value1 value2 ...#取出set中的所有值smembers key#判断set中是否含有value,1代表有，0代表没有sismember key value#删除某个元素srem key value1 value2 ...#随机从集合中吐出一个值spop key#取两个集合的交集sinter key1 key2#取两个集合的并集sunion key1 key2#取两个集合的差集sdiff key1 key2 (4)Hash 1234567891011121314#给key集合中的field键赋值valuehset key field value#获取key集合中的值hget key field#批量设置field,valuehmset key field1 value1 field2 value2...#查看哈希表中给定域field是否存在hexists key field#列出该hash集合的所有fieldhkeys key#列出该hash集合的所有valuehvals key#在哈希表key中的域field的值上加上增量hincrby key field increment (5)Zset 1234567891011121314#将一个或多个元素加入刀集合key中zadd key score1 value1 score2 value2 ...#返回指定下标间的元素zrange key start stop#取出分数在score1到score2只见的值,score1&lt;score2zrangebyscore key score1 scroe2 [withscores]#取出分数在score1到score2只见的值，从大到小排序,score1&gt;score2zrevrangebyscore key score1 scroe2 [withscores]#删除指定值的元素zrem key value#统计该集合指定分区内元素个数zcount key min max#返回该值在集合中的排名，从0开始zrank key value 2.2发布订阅1234#订阅频道subscribe channel#发送消息publish channel meaasge 2.3Jedis的使用12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[]},{"title":"基于Qt的自制跨平台取色器","slug":"LTColor","date":"2022-10-17T15:20:20.000Z","updated":"2024-05-14T14:59:28.592Z","comments":false,"path":"LTColor/","permalink":"http://example.com/LTColor/","excerpt":"","text":"1.下载一个简易的跨平台屏幕取色器，基于Qt开发。 仓库地址：543211494&#x2F;LTColor 点击此处获取已经打包好的程序，解压即用。 2.介绍该程序的原理很简单，取色时先抓取全屏。再打开一个全屏窗口，将之前抓取的全屏作为背景。同时该全屏窗口有一个子窗口，在子窗口上放大绘制当前鼠标附近15x15的像素点，作为放大镜帮助取色。 3.使用3.1ubuntu下使用123456#下载并解压tar xvJf LTColor-linux-x64-1.0.tar.xz#进入解压后所在文件夹目录启动程序sudo sh ./LTColor.sh#如果出现黑屏的情况可能是开启了wayland,#vi /etc/gdm/custom.conf,令WaylandEnable=false重启即可 运行截图如下，图二左上角为放大镜。 3.2windows下使用解压，双击LTColor.exe即可。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Qt学习笔记","slug":"qt5-note","date":"2022-10-17T13:48:20.000Z","updated":"2024-05-14T16:25:21.690Z","comments":false,"path":"qt5-note/","permalink":"http://example.com/qt5-note/","excerpt":"","text":"1.安装1.1ubuntu下安装教程：https://subingwen.cn/qt/ 官网下载：https://download.qt.io/archive/qt/ 国内镜像地址：https://mirrors.cloud.tencent.com/qt/ 123456sudo apt-get install gcc #安装gcc编译器sudo apt-get install g++ #安装g++编译器sudo apt-get install make #安装make构建套件sudo apt-get install libgl1-mesa-dev #安装OpenGL核心库chmod 777 qt-opensource-linux-x64-5.12.12.run./qt-opensource-linux-x64-5.12.12.run 添加环境变量 12export PATH=/home/lzy/Downloads/qt/5.12.12/gcc_64/bin:$PATHexport PATH=/home/lzy/Downloads/qt/5.12.12/Tools/QtCreator/bin:$PATH &#x2F;etc&#x2F;gdm3&#x2F;custom.conf #WaylandEnable&#x3D;false 删除这个# 无法正常启动时可在全局变量中加这个查看原因export QT_DEBUG_PLUGINS&#x3D;1 如果有以下报错 1234567891011121314Got keys from plugin meta data (&quot;xcb&quot;)QFactoryLoader::QFactoryLoader() checking directory path &quot;/home/lzy/Downloads/qt/Tools/QtCreator/bin/platforms&quot; ...Cannot load library /home/lzy/Downloads/qt/Tools/QtCreator/lib/Qt/plugins/platforms/libqxcb.so: (libxcb-xinerama.so.0: cannot open shared object file: No such file or directory)QLibraryPrivate::loadPlugin failed on &quot;/home/lzy/Downloads/qt/Tools/QtCreator/lib/Qt/plugins/platforms/libqxcb.so&quot; : &quot;Cannot load library /home/lzy/Downloads/qt/Tools/QtCreator/lib/Qt/plugins/platforms/libqxcb.so: (libxcb-xinerama.so.0: cannot open shared object file: No such file or directory)&quot;qt.qpa.plugin: Could not load the Qt platform plugin &quot;xcb&quot; in &quot;&quot; even though it was found.This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb.Aborted (core dumped)#执行以下命令sudo apt install --reinstall libxcb-xinerama0 卸载： 12#进入安装目录./MaintenanceTool 2.使用Clion开发新建Qt项目 将Qt CMake prefix path设置为/home/lzy/Downloads/qt/5.12.12/gcc_64 或在CMakeLists中加入 set(CMAKE_PREFIX_PATH &quot;/home/lzy/Downloads/qt/5.12.12/gcc_64&quot;) 2.1使用qtdesignersettings -&gt; Tools -&gt;External Tools Program填入designer路径：/home/lzy/Downloads/qt/5.12.12/gcc_64/bin/designer Agruments填入：$FileName$ Working directory填入：$ProjectFileDir$ 对.ui文件右键External Tools 2.2ui文件报错如果出现以下报错： 123456789AutoUic error-------------&quot;SRC:/mywidget.cpp&quot;includes the uic file &quot;ui_MyWidget.h&quot;,but the user interface file &quot;MyWidget.ui&quot;could not be found in the following directories &quot;SRC:&quot;ninja: build stopped: subcommand failed. settings -&gt; Tools -&gt;External Tools Program填入uic路径：/home/lzy/Downloads/qt/5.12.12/gcc_64/bin/uic Agruments填入：$FileName$ -o ui_$FileNameWithoutExtension$.h Working directory填入：$FileDir$ 右键Qt UIC打开.ui文件生成代码 或者关掉clion重建一个项目也可以解决 2.3QMainWindow模板缺失问题Clion生成的UI文件没有**”central widget”** 其实Clion生成Qt的UI类是通过文件和代码模板实现的，Settings&gt;&gt;Editor&gt;&gt;File and Code Templates找到Qt Designer Form将里面的内容改为如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;author/&gt; &lt;comment/&gt; &lt;exportmacro/&gt; &lt;class&gt;$&#123;NAMESPACE_SPECIFIER&#125;$&#123;NAME&#125;&lt;/class&gt; &lt;widget class=&quot;$&#123;PARENT_CLASS&#125;&quot; name=&quot;$&#123;NAMESPACE_SPECIFIER&#125;$&#123;NAME&#125;&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;300&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;$&#123;NAME&#125;&lt;/string&gt; &lt;/property&gt;#if( $&#123;PARENT_CLASS&#125; == &quot;QMainWindow&quot; ) &lt;widget class=&quot;QWidget&quot; name=&quot;centralWidget&quot;/&gt; &lt;widget class=&quot;QMenuBar&quot; name=&quot;menuBar&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;25&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;/widget&gt; &lt;widget class=&quot;QToolBar&quot; name=&quot;mainToolBar&quot;&gt; &lt;attribute name=&quot;toolBarArea&quot;&gt; &lt;enum&gt;TopToolBarArea&lt;/enum&gt; &lt;/attribute&gt; &lt;attribute name=&quot;toolBarBreak&quot;&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/attribute&gt; &lt;/widget&gt; &lt;widget class=&quot;QStatusBar&quot; name=&quot;statusBar&quot;/&gt;#end &lt;/widget&gt;#if( $&#123;PARENT_CLASS&#125; == &quot;QMainWindow&quot; ) &lt;layoutdefault spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;#end &lt;pixmapfunction/&gt; &lt;connections/&gt;&lt;/ui&gt; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;author/&gt; &lt;comment/&gt; &lt;exportmacro/&gt; &lt;class&gt;$&#123;NAMESPACE_SPECIFIER&#125;$&#123;NAME&#125;&lt;/class&gt; &lt;widget class=&quot;$&#123;PARENT_CLASS&#125;&quot; name=&quot;$&#123;NAMESPACE_SPECIFIER&#125;$&#123;NAME&#125;&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;300&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;$&#123;NAME&#125;&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;pixmapfunction/&gt; &lt;connections/&gt;&lt;/ui&gt; 2.4Qt输入框不能输入中文的问题下载https://github.com/JackieMium/libfcitxplatforminputcontextplugin.so/tree/master/lib-fcitx-plugin/debian.sid.20181208 改后缀为libfcitxplatforminputcontextplugin.so，复制到/home/lzy/Downloads/qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts和/home/lzy/Downloads/qt/5.12.12/gcc_64/plugins/platforminputcontexts 12#并执行chmod +x libfcitxplatforminputcontextplugin.so 3.QtDesigner使用拖拉拽即可 4.信号与槽1234567891011121314151617181920212223242526#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; //相当于 //QWidget::setParent(parent); //ui = new Ui::MyWidget; ui-&gt;setupUi(this); //链接信号与槽，参数分别为信号来源，信号，信号接收者，信号处理函数 //这种为旧式写法，需要在函数上加上slots connect(this-&gt;ui-&gt;commitButton, SIGNAL(clicked(bool)),this, SLOT(processCommit())); //这种为新式写法，不需要在函数上加上slots //connect(this-&gt;ui-&gt;commitButton, &amp;QPushButton::clicked,this, &amp;MyWidget::processCommit);&#125;MyWidget::~MyWidget() &#123; delete ui;&#125;void MyWidget::processCommit() &#123; QString str = this-&gt;ui-&gt;cmdLineEdit-&gt;text(); this-&gt;ui-&gt;output-&gt;setText(str); QProcess *process = new QProcess(this); process-&gt;start(str);&#125; 5.添加资源文件的方法假设有一个resource文件夹里面存储了一些资源文件 新建一个文件res.qrc 1234567&lt;RCC&gt; &lt;qresource prefix=&quot;/image&quot;&gt; &lt;file&gt;resource/1.jpg&lt;/file&gt; &lt;file&gt;resource/2.jpg&lt;/file&gt; &lt;file&gt;resource/3.jpg&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 在CMakeList.txt中加入以下内容： 12345#放在find_package之后set(QRC_SOURCE_FILE res.qrc)qt5_add_resources($&#123;QRC_SOURCE_FILE&#125;)#再在add_executable中加入$&#123;QRC_SOURCE_FILE&#125;,例如：add_executable(test main.cpp MyWidget.cpp MyWidget.h MyWidget.ui $&#123;QRC_SOURCE_FILE&#125;) 引用资源方式为： 1QPixmap pixmap(&quot;:/image/resource/1.jpg&quot;); 6.定时器6.1QObject定时器头文件 1234567891011121314151617181920212223242526272829303132333435#ifndef TEST_MYWIDGET_H#define TEST_MYWIDGET_H#include &lt;QWidget&gt;#include &lt;QProcess&gt;#include &lt;iostream&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWidget; &#125;QT_END_NAMESPACEclass MyWidget : public QWidget &#123;Q_OBJECTpublic: explicit MyWidget(QWidget *parent = nullptr); ~MyWidget() override; virtual void timerEvent(QTimerEvent *event);private: Ui::MyWidget *ui; int myTimerId; int imageIndex; void start(); void pause();&#125;;#endif //TEST_MYWIDGET_H 实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; //相当于 //QWidget::setParent(parent); //ui = new Ui::MyWidget; ui-&gt;setupUi(this); connect(this-&gt;ui-&gt;startButton,&amp;QPushButton::clicked,this,&amp;MyWidget::start); connect(this-&gt;ui-&gt;pauseButton,&amp;QPushButton::clicked,this,&amp;MyWidget::pause); this-&gt;imageIndex = 1; QPixmap pixmap(&quot;:/image/resource/3.jpg&quot;); this-&gt;ui-&gt;imgLabel-&gt;setPixmap(pixmap);&#125;MyWidget::~MyWidget() &#123; delete ui;&#125;void MyWidget::start() &#123; /* 开启定时器，返回定时器编号 */ this-&gt;myTimerId = this-&gt;startTimer(1000);&#125;void MyWidget::pause() &#123; this-&gt;killTimer(this-&gt;myTimerId);&#125;void MyWidget::timerEvent(QTimerEvent *event)&#123; /* 不是当前定时器触发的 */ if(event-&gt;timerId()!=this-&gt;myTimerId)&#123; return; &#125; this-&gt;imageIndex++; if(this-&gt;imageIndex&gt;3)&#123; this-&gt;imageIndex = 1; &#125; QString path(&quot;:/image/resource/&quot;+QString::number(this-&gt;imageIndex)+&quot;.jpg&quot;); std::cout&lt;&lt;path.toStdString()&lt;&lt;std::endl; QPixmap pixmap(path); this-&gt;ui-&gt;imgLabel-&gt;setPixmap(pixmap);&#125; 6.2QTimer定时器头文件 12345678910111213141516171819202122232425262728293031323334353637#ifndef TEST_MYWIDGET_H#define TEST_MYWIDGET_H#include &lt;QWidget&gt;#include &lt;QProcess&gt;#include &lt;QTimer&gt;#include &lt;iostream&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWidget; &#125;QT_END_NAMESPACEclass MyWidget : public QWidget &#123;Q_OBJECTpublic: explicit MyWidget(QWidget *parent = nullptr); ~MyWidget() override;private: Ui::MyWidget *ui; QTimer *timer; int imageIndex;private slots: void start(); void pause(); void timeout();&#125;;#endif //TEST_MYWIDGET_H 实现类 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; //相当于 //QWidget::setParent(parent); //ui = new Ui::MyWidget; ui-&gt;setupUi(this); timer = new QTimer(); connect(this-&gt;ui-&gt;startButton,&amp;QPushButton::clicked,this,&amp;MyWidget::start); connect(this-&gt;ui-&gt;pauseButton,&amp;QPushButton::clicked,this,&amp;MyWidget::pause); this-&gt;imageIndex = 1; QPixmap pixmap(&quot;:/image/resource/1.jpg&quot;); this-&gt;ui-&gt;imgLabel-&gt;setPixmap(pixmap); /* 定时器时间到了发出timeout信号 */ connect(this-&gt;timer,&amp;QTimer::timeout,this,&amp;MyWidget::timeout);&#125;MyWidget::~MyWidget() &#123; delete ui; delete timer;&#125;void MyWidget::start() &#123; this-&gt;timer-&gt;start(1000);&#125;void MyWidget::pause() &#123; this-&gt;timer-&gt;stop();&#125;void MyWidget::timeout()&#123; this-&gt;imageIndex++; if(this-&gt;imageIndex&gt;3)&#123; this-&gt;imageIndex = 1; &#125; QString path(&quot;:/image/resource/&quot;+QString::number(this-&gt;imageIndex)+&quot;.jpg&quot;); std::cout&lt;&lt;path.toStdString()&lt;&lt;std::endl; QPixmap pixmap(path); this-&gt;ui-&gt;imgLabel-&gt;setPixmap(pixmap);&#125; 7.QMainWindow(实现简易记事本)头文件 1234567891011121314151617181920212223242526272829303132333435363738#ifndef TEST_MYWINDOW_H#define TEST_MYWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QFileDialog&gt;#include &lt;QMessageBox&gt;#include &lt;QKeyEvent&gt;#include &lt;iostream&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWindow; &#125;QT_END_NAMESPACEclass MyWindow : public QMainWindow &#123;Q_OBJECTpublic: explicit MyWindow(QWidget *parent = nullptr); ~MyWindow() override; /* 重写虚函数 */ void keyPressEvent(QKeyEvent *event);private: Ui::MyWindow *ui; QString fileName;private slots: void newActionSlot(); void openActionSlot(); void saveActionSlot();&#125;;#endif //TEST_MYWINDOW_H 实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;MyWindow.h&quot;#include &quot;ui_MyWindow.h&quot;MyWindow::MyWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MyWindow) &#123; ui-&gt;setupUi(this); this-&gt;fileName== nullptr; connect(this-&gt;ui-&gt;newAction,&amp;QAction::triggered,this,&amp;MyWindow::newActionSlot); connect(this-&gt;ui-&gt;openAction,&amp;QAction::triggered,this,&amp;MyWindow::openActionSlot); connect(this-&gt;ui-&gt;saveAction,&amp;QAction::triggered,this,&amp;MyWindow::saveActionSlot);&#125;MyWindow::~MyWindow() &#123; delete ui;&#125;void MyWindow::newActionSlot()&#123; this-&gt;ui-&gt;textEdit-&gt;clear(); this-&gt;setWindowTitle(&quot;新建文本文档.txt&quot;);&#125;void MyWindow::openActionSlot()&#123; /* 文件选择器 */ this-&gt;fileName = QFileDialog::getOpenFileName(this,&quot;选择一个文件&quot;,QCoreApplication::applicationFilePath(),&quot;*.*&quot;); if(fileName.isEmpty())&#123; QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;); &#125;else&#123; std::cout&lt;&lt;fileName.toStdString()&lt;&lt;std::endl; /* 打开文件 */ QFile file(fileName); file.open(QIODevice::ReadOnly); QByteArray buffer = file.readAll(); /* 读取文件内容 */ this-&gt;ui-&gt;textEdit-&gt;setText(QString(buffer)); file.close(); &#125;&#125;void MyWindow::saveActionSlot()&#123; QString path = QFileDialog::getSaveFileName(this, &quot;选择一个文件&quot;, QCoreApplication::applicationFilePath(), &quot;*.*&quot;); if(path.isEmpty())&#123; QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;); &#125;else&#123; /* 打开文件 */ QFile file(path); file.open(QIODevice::WriteOnly); /* 写入文件 */ QByteArray buffer; buffer.append(this-&gt;ui-&gt;textEdit-&gt;toPlainText()); file.write(buffer); file.close(); &#125;&#125;/** * 键盘事件,实现ctrl+s保存 */void MyWindow::keyPressEvent(QKeyEvent *event)&#123; if(this-&gt;fileName== nullptr)&#123; return; &#125; if(event-&gt;modifiers()==Qt::ControlModifier &amp;&amp; event-&gt;key()==Qt::Key_S)&#123; /* 打开文件 */ QFile file(fileName); file.open(QIODevice::WriteOnly); /* 写入文件 */ QByteArray buffer; buffer.append(this-&gt;ui-&gt;textEdit-&gt;toPlainText()); file.write(buffer); file.close(); &#125;&#125; ui文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;MyWindow&lt;/class&gt; &lt;widget class=&quot;QMainWindow&quot; name=&quot;MyWindow&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;754&lt;/width&gt; &lt;height&gt;545&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;MyWindow&lt;/string&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;centralWidget&quot;&gt; &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;verticalLayout&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QTextEdit&quot; name=&quot;textEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QMenuBar&quot; name=&quot;menuBar&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;754&lt;/width&gt; &lt;height&gt;28&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;widget class=&quot;QMenu&quot; name=&quot;menu_F&quot;&gt; &lt;property name=&quot;title&quot;&gt; &lt;string&gt;文件(F)&lt;/string&gt; &lt;/property&gt; &lt;addaction name=&quot;newAction&quot;/&gt; &lt;addaction name=&quot;openAction&quot;/&gt; &lt;addaction name=&quot;saveAction&quot;/&gt; &lt;/widget&gt; &lt;addaction name=&quot;menu_F&quot;/&gt; &lt;/widget&gt; &lt;widget class=&quot;QToolBar&quot; name=&quot;mainToolBar&quot;&gt; &lt;attribute name=&quot;toolBarArea&quot;&gt; &lt;enum&gt;TopToolBarArea&lt;/enum&gt; &lt;/attribute&gt; &lt;attribute name=&quot;toolBarBreak&quot;&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/attribute&gt; &lt;/widget&gt; &lt;widget class=&quot;QStatusBar&quot; name=&quot;statusBar&quot;/&gt; &lt;action name=&quot;newAction&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;新建(N)&lt;/string&gt; &lt;/property&gt; &lt;/action&gt; &lt;action name=&quot;openAction&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;打开(O)&lt;/string&gt; &lt;/property&gt; &lt;/action&gt; &lt;action name=&quot;saveAction&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;另存为(S)&lt;/string&gt; &lt;/property&gt; &lt;/action&gt; &lt;/widget&gt; &lt;layoutdefault spacing=&quot;6&quot; margin=&quot;11&quot;/&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; 8.TCP服务器在CMakeLists.txt中添加Network 123456789101112131415161718192021222324cmake_minimum_required(VERSION 3.21)project(TCPCLient)set(CMAKE_CXX_STANDARD 14)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_PREFIX_PATH &quot;/home/lzy/Downloads/qt/5.12.12/gcc_64&quot;)find_package(Qt5 COMPONENTS Core Gui Widgets Network REQUIRED)add_executable(TCPCLient main.cpp MyWidget.cpp MyWidget.h MyWidget.ui)target_link_libraries(TCPCLient Qt5::Core Qt5::Gui Qt5::Widgets Qt5::Network ) 8.1服务端123456789101112131415161718#include &lt;QApplication&gt;#include &lt;QPushButton&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;#include &lt;QHostAddress&gt;int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QTcpServer *server = new QTcpServer(); QObject::connect(server, &amp;QTcpServer::newConnection, [&amp;]()&#123; QTcpSocket *clientSocket = server-&gt;nextPendingConnection(); // 获取客户端套接字 qDebug() &lt;&lt; &quot;New connection from IP:&quot; &lt;&lt; clientSocket-&gt;peerAddress().toString() &lt;&lt; &quot;Port:&quot; &lt;&lt; clientSocket-&gt;peerPort(); // 打印客户端IP地址和端口号 &#125;); server-&gt;listen(QHostAddress::AnyIPv4,8000); return QApplication::exec();&#125; 8.2客户端头文件 123456789101112131415161718192021222324252627282930313233#ifndef TCPCLIENT_MYWIDGET_H#define TCPCLIENT_MYWIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpSocket&gt;#include &lt;QHostAddress&gt;#include &lt;QMessageBox&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWidget; &#125;QT_END_NAMESPACEclass MyWidget : public QWidget &#123;Q_OBJECTpublic: explicit MyWidget(QWidget *parent = nullptr); ~MyWidget() override;private: Ui::MyWidget *ui; QTcpSocket *socket;private slots: void processConnect(); void processCancel();&#125;;#endif //TCPCLIENT_MYWIDGET_H 实现类 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; ui-&gt;setupUi(this); this-&gt;socket = new QTcpSocket(); connect(this-&gt;ui-&gt;connectButton,&amp;QPushButton::clicked,this,&amp;MyWidget::processConnect); connect(this-&gt;ui-&gt;cancelButton,&amp;QPushButton::clicked,this,&amp;MyWidget::processCancel);&#125;MyWidget::~MyWidget() &#123; delete ui; socket-&gt;close(); delete socket;&#125;void MyWidget::processConnect()&#123; QString ip = this-&gt;ui-&gt;ipEdit-&gt;text(); QString port = this-&gt;ui-&gt;portEdit-&gt;text(); qDebug()&lt;&lt;ip&lt;&lt;&quot;:&quot;&lt;&lt;port; QHostAddress address(ip); /* 连接服务器 */ this-&gt;socket-&gt;connectToHost(address,port.toShort()); /* 连接成功发出信号 */ connect(this-&gt;socket,&amp;QTcpSocket::connected,[this]&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;连接成功&quot;); &#125;); /* 连接断开发出信号 */ connect(this-&gt;socket,&amp;QTcpSocket::disconnected,[this]&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;连接断开&quot;); &#125;);&#125;void MyWidget::processCancel()&#123; this-&gt;close();&#125; ui文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;MyWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;MyWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;273&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;MyWidget&lt;/string&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;horizontalLayoutWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;60&lt;/x&gt; &lt;y&gt;30&lt;/y&gt; &lt;width&gt;271&lt;/width&gt; &lt;height&gt;41&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;服务器地址&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QLineEdit&quot; name=&quot;ipEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;horizontalLayoutWidget_2&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;60&lt;/x&gt; &lt;y&gt;100&lt;/y&gt; &lt;width&gt;271&lt;/width&gt; &lt;height&gt;41&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_2&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;服务器端口&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QLineEdit&quot; name=&quot;portEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;horizontalLayoutWidget_3&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;60&lt;/x&gt; &lt;y&gt;150&lt;/y&gt; &lt;width&gt;271&lt;/width&gt; &lt;height&gt;80&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_3&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QPushButton&quot; name=&quot;connectButton&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;连接&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QPushButton&quot; name=&quot;cancelButton&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;取消&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; 9.数据库操作9.1编译MySQL驱动12#安装Mysql开发工具sudo apt-get install libmysqlclient-dev libqt5sql5-mysql 进入源码路径/home/lzy/Downloads/qt/5.12.12/Src/qtbase/src/plugins/sqldrivers/mysql 修改mysql.pro文件 123456789101112131415TARGET = qsqlmysqlHEADERS += $$PWD/qsql_mysql_p.hSOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp#注释三行#QMAKE_USE += mysqlOTHER_FILES += mysql.jsonPLUGIN_CLASS_NAME = QMYSQLDriverPlugininclude(../qsqldriverbase.pri)#新增三行INCLUDEPATH+=/usr/include/mysqlLIBS+=-L/usr/lib/x86_64-linux-gnu -lmysqlclientDESTDIR = ./lib 进入上一级目录，修改qsqldriverbase.pri文件 1234567891011QT = core core-private sql-private# For QMAKE_USE in the parent projects.#修改这一行#include($$shadowed($$PWD)/qtsqldrivers-config.pri)include(./configure.pri)PLUGIN_TYPE = sqldriversload(qt_plugin)DEFINES += QT_NO_CAST_TO_ASCII QT_NO_CAST_FROM_ASCII 123cd mysql/home/lzy/Downloads/qt/5.12.12/gcc_64/bin/qmakemake 将libqsqlmysql.so复制至/home/lzy/Downloads/qt/5.12.12/gcc_64/plugins/sqldrivers 9.2数据库读写操作头文件： 1234567891011121314151617181920212223242526272829303132333435#ifndef SQL_MYWIDGET_H#define SQL_MYWIDGET_H#include &lt;QWidget&gt;#include &lt;QSqlDatabase&gt;#include &lt;QMessageBox&gt;#include &lt;QSqlQuery&gt;#include &lt;QDebug&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWidget; &#125;QT_END_NAMESPACEclass MyWidget : public QWidget &#123;Q_OBJECTpublic: explicit MyWidget(QWidget *parent = nullptr); ~MyWidget() override;private: Ui::MyWidget *ui; QSqlDatabase db;private slots: void processInsert(); void processQuery();&#125;;#endif //SQL_MYWIDGET_H 实现类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; ui-&gt;setupUi(this); db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;); db.setDatabaseName(&quot;test&quot;); db.setHostName(&quot;127.0.0.1&quot;); db.setPort(3307); db.setUserName(&quot;root&quot;); db.setPassword(&quot;123456&quot;); if(db.open())&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;MySQL连接成功&quot;); &#125;else&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;MySQL连接失败&quot;); &#125; connect(this-&gt;ui-&gt;insertButton,&amp;QPushButton::clicked,this,&amp;MyWidget::processInsert); connect(this-&gt;ui-&gt;queryButton,&amp;QPushButton::clicked,this,&amp;MyWidget::processQuery);&#125;MyWidget::~MyWidget() &#123; delete ui;&#125;void MyWidget::processInsert()&#123; QString name = this-&gt;ui-&gt;nameEdit-&gt;text(); QString id = this-&gt;ui-&gt;idEdit-&gt;text(); QString age = this-&gt;ui-&gt;ageEdit-&gt;text(); QString sql = QString(&quot;INSERT INTO test.student (name, id, age) VALUES (&#x27;%1&#x27;,&#x27;%2&#x27;,%3);&quot;) .arg(name).arg(id).arg(age); QSqlQuery query; if(query.exec(sql))&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;插入成功&quot;); &#125;else&#123; QMessageBox::information(this,&quot;提示&quot;,&quot;插入失败&quot;); &#125;&#125;void MyWidget::processQuery()&#123; QSqlQuery query; query.exec(&quot;SELECT * FROM test.student;&quot;); while (query.next())&#123; qDebug()&lt;&lt;&quot;name:&quot;&lt;&lt;query.value(0).toString() &lt;&lt;&quot;,id:&quot;&lt;&lt;query.value(1).toString() &lt;&lt;&quot;,age&quot;&lt;&lt;query.value(2).toInt(); &#125;&#125; ui文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;MyWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;MyWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;362&lt;/width&gt; &lt;height&gt;261&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;MyWidget&lt;/string&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;70&lt;/x&gt; &lt;y&gt;30&lt;/y&gt; &lt;width&gt;221&lt;/width&gt; &lt;height&gt;141&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;verticalLayout&quot;&gt; &lt;item&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;姓名&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QLineEdit&quot; name=&quot;nameEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;item&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_2&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;学号&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QLineEdit&quot; name=&quot;idEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;item&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_3&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_3&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;年龄&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QLineEdit&quot; name=&quot;ageEdit&quot;/&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;70&lt;/x&gt; &lt;y&gt;170&lt;/y&gt; &lt;width&gt;221&lt;/width&gt; &lt;height&gt;51&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;horizontalLayout_4&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QPushButton&quot; name=&quot;queryButton&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;查询&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QPushButton&quot; name=&quot;insertButton&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;插入&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; CMakeLists.txt 123456789101112131415161718192021222324cmake_minimum_required(VERSION 3.21)project(sql)set(CMAKE_CXX_STANDARD 14)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_PREFIX_PATH &quot;/home/lzy/Downloads/qt/5.12.12/gcc_64&quot;)find_package(Qt5 COMPONENTS Core Gui Widgets Sql REQUIRED)add_executable(sql main.cpp MyWidget.cpp MyWidget.h MyWidget.ui)target_link_libraries(sql Qt5::Core Qt5::Gui Qt5::Widgets Qt5::Sql ) 10.发起Http请求10.1客户端头文件 1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef SQL_MYWIDGET_H#define SQL_MYWIDGET_H#include &lt;QWidget&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;QNetworkReply&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MyWidget; &#125;QT_END_NAMESPACEclass MyWidget : public QWidget &#123;Q_OBJECTpublic: explicit MyWidget(QWidget *parent = nullptr); ~MyWidget() override;private: Ui::MyWidget *ui; QNetworkAccessManager* networkManager; QNetworkReply* getReply; QNetworkReply* postReply;private slots: void sendGetRequest(); void sendPostRequest(); void processGetReply(); void processPostReply();&#125;;#endif //SQL_MYWIDGET_H 实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;QJsonDocument&gt;#include &lt;QJsonObject&gt;#include &lt;QUrlQuery&gt;#include &quot;MyWidget.h&quot;#include &quot;ui_MyWidget.h&quot;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget) &#123; ui-&gt;setupUi(this); this-&gt;networkManager = new QNetworkAccessManager(this); connect(this-&gt;ui-&gt;getButton,&amp;QPushButton::clicked,this,&amp;MyWidget::sendGetRequest); connect(this-&gt;ui-&gt;postButton,&amp;QPushButton::clicked,this,&amp;MyWidget::sendPostRequest);&#125;MyWidget::~MyWidget() &#123; delete ui; delete networkManager;&#125;void MyWidget::sendGetRequest()&#123; QNetworkRequest request; QString url = &quot;http://127.0.0.1:8080/api/processGet&quot;; url.append(&quot;?param1=param1&amp;param2=param2&quot;); request.setUrl(QUrl(url)); request.setHeader(QNetworkRequest::ContentTypeHeader,&quot;application/x-www-form-urlencoded&quot;); this-&gt;getReply = this-&gt;networkManager-&gt;get(request); connect(this-&gt;getReply,&amp;QNetworkReply::finished,this,&amp;MyWidget::processGetReply);&#125;void MyWidget::processGetReply()&#123; if (this-&gt;getReply-&gt;error() == QNetworkReply::NoError)&#123; QByteArray array = this-&gt;getReply-&gt;readAll(); qInfo()&lt;&lt;&quot;data:&quot;&lt;&lt;QString::fromUtf8(array)&lt;&lt;&quot;\\n&quot;; &#125;else&#123; qInfo()&lt;&lt;&quot;error:&quot;&lt;&lt;this-&gt;getReply-&gt;error(); &#125; this-&gt;getReply-&gt;deleteLater();&#125;void MyWidget::sendPostRequest()&#123; QNetworkRequest request; QString url = &quot;http://127.0.0.1:8080/api/processPost&quot;; request.setUrl(QUrl(url)); request.setHeader(QNetworkRequest::ContentTypeHeader,&quot;application/x-www-form-urlencoded&quot;); /* 设置参数 */ /* 这种方式传递json字符串，用@RequestBody接收 */// QJsonDocument document;// QJsonObject obj;// obj.insert(&quot;param1&quot;, &quot;postParam1&quot;);// obj.insert(&quot;param2&quot;, &quot;postParam2&quot;);// document.setObject(obj);// QByteArray postData = document.toJson(QJsonDocument::Compact);// this-&gt;postReply = this-&gt;networkManager-&gt;post(request,postData); /* 这种方式传递param1=value1&amp;param2=value2，用@RequestParam接收 */ QUrlQuery postData; postData.addQueryItem(&quot;param1&quot;, &quot;value1&quot;); postData.addQueryItem(&quot;param2&quot;, &quot;value2&quot;); QByteArray postDataBytes = postData.toString(QUrl::FullyEncoded).toUtf8(); this-&gt;postReply = this-&gt;networkManager-&gt;post(request,postDataBytes); /* 参数未写入url中 */ qInfo()&lt;&lt;request.url().toString(); qInfo()&lt;&lt;postDataBytes; connect(this-&gt;postReply,&amp;QNetworkReply::finished,this,&amp;MyWidget::processPostReply);&#125;void MyWidget::processPostReply()&#123; if (this-&gt;postReply-&gt;error() == QNetworkReply::NoError)&#123; QByteArray array = this-&gt;postReply-&gt;readAll(); qInfo()&lt;&lt;&quot;data:&quot;&lt;&lt;QString::fromUtf8(array)&lt;&lt;&quot;\\n&quot;; &#125;else&#123; qInfo()&lt;&lt;&quot;error:&quot;&lt;&lt;this-&gt;postReply-&gt;error(); &#125; this-&gt;postReply-&gt;deleteLater();&#125; 10.2服务端123456789101112131415161718192021222324252627282930package org.qt.request.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;/** * @author lzy */@Controller@ResponseBodypublic class TestController &#123; @RequestMapping(value = &quot;/api/processGet&quot;,method = RequestMethod.GET,produces = &quot;application/json;charset=utf-8&quot;) public String processGet(@RequestParam(&quot;param1&quot;)String param1,@RequestParam(&quot;param2&quot;)String param2)&#123; String result = &quot;收到请求：param1=&quot;+param1+&quot;,param2=&quot;+param2; System.out.println(result); return result; &#125; @RequestMapping(value = &quot;/api/processPost&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=utf-8&quot;) public String processPost(@RequestParam(&quot;param1&quot;)String param1,@RequestParam(&quot;param2&quot;)String param2)&#123; String result = &quot;收到请求：param1=&quot;+param1+&quot;,param2=&quot;+param2; System.out.println(result); return result; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Selenium用法","slug":"selenium-note","date":"2022-10-07T10:08:22.000Z","updated":"2024-05-14T14:29:06.336Z","comments":false,"path":"selenium-note/","permalink":"http://example.com/selenium-note/","excerpt":"","text":"1.下载驱动查看Chrome浏览器版本：chrome:&#x2F;&#x2F;version&#x2F; 下载地址：https://chromedriver.storage.googleapis.com/index.html 高版本下载：https://googlechromelabs.github.io/chrome-for-testing/ 2.使用selenium2.1python版安装： 1pip install selenium 示例： 爬取京东首页商品信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from time import sleepfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.chrome.service import Service# selenium,# Version: 4.13.0if __name__ == &#x27;__main__&#x27;: # 不自动关闭浏览器 option = webdriver.ChromeOptions() # 不自动关闭浏览器 # option.add_experimental_option(&quot;detach&quot;, True) # 设置lang和User-Agent信息，防止反爬虫检测 option.add_argument(&#x27;lang=zh_CN.UTF-8&#x27;) UserAgent = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.101 Safari/537.36&#x27; option.add_argument(&#x27;User-Agent=&#x27; + UserAgent) #页面部分内容是动态加载得时候，无头模式默认size为0x0，需要设置最大化窗口并设置windowssize，不然会出现显示不全的问题 option.add_argument(&#x27;window-size=1920x1080&#x27;) # 无界面的浏览器 option.add_argument(&quot;headless&quot;) # 指定绝对路径的方式 path = r&#x27;E:\\Python\\chromedriver-win32\\chromedriver.exe&#x27; #老版本指定驱动路径 #browser = webdriver.Chrome(executable_path=path) #如果需要指定路径，但是路径在新版本中被重构到 Service 函数中了 service = Service(executable_path=path) browser = webdriver.Chrome(options=option,service=service) browser.get(r&#x27;https://www.jd.com/&#x27;) # 执行向下滚动操作 browser.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight)&quot;) #等待页面加载，隐式等待 browser.implicitly_wait(5) #显式等待 # sleep(5) lis = browser.find_elements(by=By.CSS_SELECTOR,value=&quot;li.more2_item.more2_item_good.hover-on&quot;) for li in lis: str = &quot;商品:&quot;+li.find_element(by=By.CSS_SELECTOR,value=&quot;.more2_info_name&quot;).text; str += &quot;,价格:&quot;+li.find_element(by=By.CSS_SELECTOR,value=&quot;.more2_info_price_txt&quot;).text print(str) #页面源码 print(browser.page_source) # 关闭浏览器 browser.close() 2.2java版pom.xml: 12345&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;&lt;/dependency&gt; 示例: 爬取京东首页商品信息 1234567891011121314151617181920212223242526272829303132333435363738394041package org.example;import org.openqa.selenium.By;import org.openqa.selenium.JavascriptExecutor;import org.openqa.selenium.WebDriver;import org.openqa.selenium.WebElement;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.chrome.ChromeOptions;import java.util.List;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main( String[] args )&#123; /* 驱动安装的路径 */ System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;E:\\\\Python\\\\chromedriver-win32\\\\chromedriver.exe&quot;); ChromeOptions options = new ChromeOptions(); /* 无界面的浏览器 */ options.addArguments(&quot;headless&quot;); /* 设置lang和User-Agent信息，防止反爬虫检测 */ options.addArguments(&quot;lang=zh_CN.UTF-8&quot;); options.addArguments(&quot;User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.101 Safari/537.36&quot;); /* 页面部分内容是动态加载得时候，无头模式默认size为0x0，需要设置最大化窗口并设置windowssize，不然会出现显示不全的问题 */ options.addArguments(&quot;window-size=1920x1080&quot;); WebDriver driver = new ChromeDriver(options); driver.get(&quot;https://www.jd.com/&quot;); /* 执行向下滚动操作 */ ((JavascriptExecutor) driver).executeScript(&quot;window.scrollTo(0, document.body.scrollHeight)&quot;); /* 隐式等待 */ driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); List&lt;WebElement&gt; list = driver.findElements(By.cssSelector(&quot;li.more2_item.more2_item_good.hover-on&quot;)); for(int i = 0;i&lt;list.size();i++)&#123; System.out.print(&quot;商品:&quot;+list.get(i).findElement(By.cssSelector(&quot;.more2_info_name&quot;)).getText()); System.out.println(&quot;,价格:&quot;+list.get(i).findElement(By.cssSelector(&quot;.more2_info_price_txt&quot;)).getText()); &#125; /* 退出WebDriver，关闭所有窗口 */ //driver.quit(); /* 关闭当前窗口或标签页 */ driver.close(); &#125;&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[]},{"title":"VueQuillEditor用法笔记","slug":"VueQuillEditor-note","date":"2022-09-17T20:01:02.000Z","updated":"2024-05-14T14:44:45.000Z","comments":false,"path":"VueQuillEditor-note/","permalink":"http://example.com/VueQuillEditor-note/","excerpt":"","text":"1.安装1234npm install vue-quill-editor --save//语法高亮npm install highlight.js 2.main.js12345import VueQuillEditor from &#x27;vue-quill-editor&#x27;import &#x27;quill/dist/quill.core.css&#x27;import &#x27;quill/dist/quill.snow.css&#x27;import &#x27;quill/dist/quill.bubble.css&#x27;Vue.use(VueQuillEditor); 3.使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;template&gt; &lt;div&gt; &lt;div class=&quot;container&quot;&gt; &lt;quill-editor class=&quot;ql-container&quot; ref=&quot;myTextEditor&quot; v-model=&quot;content&quot; :options=&quot;editorOption&quot; @blur=&quot;onEditorBlur($event)&quot; @focus=&quot;onEditorFocus($event)&quot; @ready=&quot;onEditorReady($event)&quot; @change=&quot;onEditorChange($event)&quot;&gt; &lt;/quill-editor&gt; &lt;/div&gt; &lt;!-- 回显获取的数据 --&gt; &lt;button @click=&quot;show&quot;&gt;展示文本内容&lt;/button&gt; &lt;div class=&quot;ql-snow container1&quot;&gt; &lt;div class=&quot;ql-editor&quot; v-html=&quot;data&quot; v-highlight&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import java from &#x27;highlight.js&#x27;; export default &#123; data () &#123; return &#123; data:`&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;String&lt;/span&gt;[] args)&lt;/span&gt;&lt;/span&gt;&#123; System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello,world&quot;&lt;/span&gt;);&#125;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h1 class=&quot;ql-indent-1&quot;&gt;&lt;strong&gt;测试富文本编辑器&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(230, 0, 0);&quot;&gt;ABCD&lt;/span&gt;&lt;/p&gt;`, content: null, editorOption: &#123; modules: &#123; toolbar: [ [&quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;strike&quot;], // 加粗 斜体 下划线 删除线 [&quot;blockquote&quot;, &quot;code-block&quot;], // 引用 代码块 [&#123; header: 1 &#125;, &#123; header: 2 &#125;], // 1、2 级标题 [&#123; list: &quot;ordered&quot; &#125;, &#123; list: &quot;bullet&quot; &#125;], // 有序、无序列表 [&#123; script: &quot;sub&quot; &#125;, &#123; script: &quot;super&quot; &#125;], // 上标/下标 [&#123; indent: &quot;-1&quot; &#125;, &#123; indent: &quot;+1&quot; &#125;], // 缩进 // [&#123;&#x27;direction&#x27;: &#x27;rtl&#x27;&#125;], // 文本方向 [&#123; size: [&quot;small&quot;, false, &quot;large&quot;, &quot;huge&quot;] &#125;], // 字体大小 [&#123; header: [1, 2, 3, 4, 5, 6, false] &#125;], // 标题 [&#123; color: [] &#125;, &#123; background: [] &#125;], // 字体颜色、字体背景颜色 [&#123; font: [] &#125;], // 字体种类 [&#123; align: [] &#125;], // 对齐方式 [&quot;clean&quot;], // 清除文本格式 //[&quot;link&quot;, &quot;image&quot;, &quot;video&quot;] // 链接、图片、视频 ], //工具菜单栏配置 syntax:&#123; //语法高亮 highlight:text =&gt;&#123; return java.highlightAuto(text).value &#125; &#125; &#125;, placeholder: &#x27;请在这里添加产品描述&#x27;, //提示 readyOnly: false, //是否只读 theme: &#x27;snow&#x27;, //主题 snow/bubble syntax: true, //语法检测 &#125; &#125; &#125;, methods: &#123; // 失去焦点 onEditorBlur(editor) &#123;&#125;, // 获得焦点 onEditorFocus(editor) &#123;&#125;, // 开始 onEditorReady(editor) &#123;&#125;, // 值发生变化 onEditorChange(editor) &#123; console.log(&quot;change!&quot;); &#125;, show(editor)&#123; console.log(this.content); &#125; &#125;, computed: &#123; editor() &#123; return this.$refs.myTextEditor.quillEditor; &#125; &#125;, mounted() &#123; // console.log(&#x27;this is my editor&#x27;,this.editor); &#125; &#125; &lt;/script&gt;&lt;style&gt;.ql-container &#123; min-height: 400px;&#125;.container&#123; width: 70%; border: 1px red solid;&#125;.container1&#123; width: 70%; border: 1px red solid; height: 300px;&#125;.border&#123; width: 30px; height: 30px; border: 1px red solid;&#125;&lt;/style&gt; 4.自定义字体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;template&gt; &lt;div&gt; &lt;div class=&quot;container&quot;&gt; &lt;quill-editor class=&quot;ql-container&quot; ref=&quot;myTextEditor&quot; v-model=&quot;content&quot; :options=&quot;editorOption&quot; @blur=&quot;onEditorBlur($event)&quot; @focus=&quot;onEditorFocus($event)&quot; @ready=&quot;onEditorReady($event)&quot; @change=&quot;onEditorChange($event)&quot;&gt; &lt;/quill-editor&gt; &lt;/div&gt; &lt;button @click=&quot;show&quot;&gt;展示文本内容&lt;/button&gt; &lt;!-- 回显获取的数据 --&gt; &lt;div class=&quot;ql-snow container1&quot;&gt; &lt;div class=&quot;ql-editor&quot; v-html=&quot;data&quot; v-highlight&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import java from &#x27;highlight.js&#x27;; import &#123; quillEditor,Quill &#125; from &quot;vue-quill-editor&quot;; //设置字体大小 let fontSizeStyle=Quill.import(&#x27;attributors/style/size&#x27;) //引入这个后会把样式写在style上 fontSizeStyle.whitelist=[&#x27;45px&#x27;,&#x27;60px&#x27;,&#x27;90px&#x27;] Quill.register(fontSizeStyle,true) //设置字体样式 let Font = Quill.import(&#x27;attributors/style/font&#x27;) //引入这个后会把样式写在style上 let fonts = [false, &#x27;SimSun&#x27;, &#x27;SimHei&#x27;,&#x27;Microsoft-YaHei&#x27;,&#x27;KaiTi&#x27;,&#x27;FangSong&#x27;,&#x27;Arial&#x27;] Font.whitelist = fonts //将字体加入到白名单 Quill.register(Font, true) export default &#123; data () &#123; return &#123; data:`&lt;pre class=&quot;ql-syntax&quot; spellcheck=&quot;false&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;String&lt;/span&gt;[] args)&lt;/span&gt;&lt;/span&gt;&#123; System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello,world&quot;&lt;/span&gt;);&#125;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h1 class=&quot;ql-indent-1&quot;&gt;&lt;strong style=&quot;font-family: KaiTi;&quot;&gt;测试富文本编辑器&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span style=&quot;color: rgb(230, 0, 0);&quot;&gt;ABCD&lt;/span&gt;&lt;span style=&quot;color: rgb(230, 0, 0); font-family: KaiTi;&quot;&gt;&lt;span class=&quot;ql-cursor&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;`, content: null, editorOption: &#123; modules: &#123; toolbar: [ [&quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;strike&quot;], // 加粗 斜体 下划线 删除线 [&quot;blockquote&quot;, &quot;code-block&quot;], // 引用 代码块 [&#123; header: 1 &#125;, &#123; header: 2 &#125;], // 1、2 级标题 [&#123; list: &quot;ordered&quot; &#125;, &#123; list: &quot;bullet&quot; &#125;], // 有序、无序列表 [&#123; script: &quot;sub&quot; &#125;, &#123; script: &quot;super&quot; &#125;], // 上标/下标 [&#123; indent: &quot;-1&quot; &#125;, &#123; indent: &quot;+1&quot; &#125;], // 缩进 // [&#123;&#x27;direction&#x27;: &#x27;rtl&#x27;&#125;], // 文本方向 [&#123; size: [&#x27;45px&#x27;,&#x27;60px&#x27;,&#x27;90px&#x27;] &#125;], // 字体大小 [&#123; header: [1, 2, 3, 4, 5, 6, false] &#125;], // 标题 [&#123; color: [] &#125;, &#123; background: [] &#125;], // 字体颜色、字体背景颜色 [&#123; font: [&#x27;SimSun&#x27;, &#x27;SimHei&#x27;,&#x27;Microsoft-YaHei&#x27;,&#x27;KaiTi&#x27;,&#x27;FangSong&#x27;,&#x27;Arial&#x27;]&#125;], // 字体种类 [&#123; align: [] &#125;], // 对齐方式 [&quot;clean&quot;], // 清除文本格式 //[&quot;link&quot;, &quot;image&quot;, &quot;video&quot;] // 链接、图片、视频 ], //工具菜单栏配置 syntax:&#123; //语法高亮 highlight:text =&gt;&#123; return java.highlightAuto(text).value &#125; &#125; &#125;, placeholder: &#x27;请在这里添加产品描述&#x27;, //提示 readyOnly: false, //是否只读 theme: &#x27;snow&#x27;, //主题 snow/bubble syntax: true, //语法检测 &#125; &#125; &#125;, methods: &#123; // 失去焦点 onEditorBlur(editor) &#123;&#125;, // 获得焦点 onEditorFocus(editor) &#123;&#125;, // 开始 onEditorReady(editor) &#123;&#125;, // 值发生变化 onEditorChange(editor) &#123; console.log(&quot;change!&quot;); &#125;, show(editor)&#123; console.log(this.content); alert(this.content); &#125; &#125;, computed: &#123; editor() &#123; return this.$refs.myTextEditor.quillEditor; &#125; &#125;, mounted() &#123; // console.log(&#x27;this is my editor&#x27;,this.editor); &#125; &#125;&lt;/script&gt;&lt;style&gt;.ql-container &#123; min-height: 400px;&#125;&lt;/style&gt;&lt;style scoped&gt;.container&#123; width: 70%; border: 1px red solid;&#125;.container1&#123; width: 70%; border: 1px red solid; height: 300px;&#125;.border&#123; width: 30px; height: 30px; border: 1px red solid;&#125;/*这里一定要写上，是用来把相关改变的配置在工具栏正常显示如果不写，字体样式的下拉会重复显示Sans Serif，字体大小的下拉会重复显示Normal*/.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-label[data-value=SimSun]::before,.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-item[data-value=SimSun]::before &#123; content: &quot;宋体&quot;; font-family: &quot;SimSun&quot;!important;&#125;.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-label[data-value=SimHei]::before,.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-item[data-value=SimHei]::before &#123; content: &quot;黑体&quot;; font-family: &quot;SimHei&quot;;&#125;.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-label[data-value=Microsoft-YaHei]::before,.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-item[data-value=Microsoft-YaHei]::before &#123; content: &quot;微软雅黑&quot;; font-family: &quot;Microsoft YaHei&quot;;&#125;.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-label[data-value=KaiTi]::before,.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-item[data-value=KaiTi]::before &#123; content: &quot;楷体&quot;; font-family: &quot;KaiTi&quot;!important;&#125;.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-label[data-value=FangSong]::before,.quill-editor &gt;&gt;&gt; .ql-picker.ql-font .ql-picker-item[data-value=FangSong]::before &#123; content: &quot;仿宋&quot;; font-family: &quot;FangSong&quot;;&#125;.quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-label[data-value=&#x27;45px&#x27;]::before, .quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-item[data-value=&#x27;45px&#x27;]::before &#123; content: &#x27;45px&#x27;;&#125;.quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-label[data-value=&#x27;60px&#x27;]::before, .quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-item[data-value=&#x27;60px&#x27;]::before &#123; content: &#x27;60px&#x27;;&#125;.quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-label[data-value=&#x27;90px&#x27;]::before, .quill-editor &gt;&gt;&gt; .ql-snow .ql-picker.ql-size .ql-picker-item[data-value=&#x27;90px&#x27;]::before &#123; content: &#x27;90px&#x27;;&#125;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"数据库复习笔记","slug":"sql-note","date":"2021-11-05T07:30:29.000Z","updated":"2024-05-14T14:38:41.499Z","comments":false,"path":"sql-note/","permalink":"http://example.com/sql-note/","excerpt":"","text":"1.关系代数1.1并、交、差 关系S1 Sno Sname Sdept 0001 Mary IS 0003 Candy IS 0004 Jam IS 关系S2 Sno Sname Sdept 0001 Mary IS 0008 Katter IS 0021 Tom IS 交：二者重复行 $$S1 \\cap S2$$ Sno Sname Sdept 0001 Mary IS 并：二者元组之和去除重复行 $$S1 \\cup S2$$ Sno Sname Sdept 0001 Mary IS 0003 Candy IS 0004 Jam IS 0008 Katter IS 0021 Tom IS 差：前者去除二者重复行 $$S1 — S2$$ Sno Sname Sdept 0003 Candy IS 0004 Jam IS 1.2笛卡尔积、投影、选择 关系S1 Sno Sname Sdept 0001 Mary IS 0003 Candy IS 0004 Jam IS 关系S2 Sno Sname Sdept 0001 Mary IS 0008 Katter IS 0021 Tom IS 笛卡尔积：将两个集合中的元组两两并联$$S1 \\times S2$$ Sno Sname Sdept Sno Sname Sdept 0001 Mary IS 0001 Mary IS 0001 Mary IS 0008 Katter IS 0001 Mary IS 0021 Tom IS 0003 Candy IS 0001 Mary IS 0003 Candy IS 0008 Katter IS 0003 Candy IS 0021 Tom IS 0004 Jam IS 0001 Mary IS 0004 Jam IS 0008 Katter IS 0004 Jam IS 0021 Tom IS 投影：对属性列的选择列出$$\\Pi_{Sno,Sname}(S1)$$ Sno Sname 0001 Mary 0003 Candy 0004 Jam 选择：根据某些条件对关系做水平切割$$\\sigma_{Sno&#x3D;0001}S1$$ Sno Sname Sdept 0001 Mary IS ### 1.3连接 θ-连接：笛卡尔积中满足条件θ的元组构成的集合 等值连接：特殊的θ-连接，θ为等值条件 自然连接：特殊的等值连接，要求两个关系中进行比较的分量必须相同属性组，并将重复属性（字段）去掉，如S1⋈S2 左外连接：自然连接（或θ连接）+左侧表中缺失的元组 右外连接：自然连接（或θ连接）+右侧表中缺失的元组 全外连接：自然连接（或θ连接）+两侧表中缺失的元组 1.4除法两个关系中的某个或某些属性出自相同的域集，记为A 除去这些属性A后对剩下的属性进行筛选 选出其取值所在的象集中包含有除数关系中对A的投影的部分 关系R A B C a1 b1 c2 a1 b2 c3 a1 b2 c1 a2 b3 c7 a2 b2 c3 a3 b4 c6 a4 b6 c6 关系S B C D b1 c2 d1 b2 c1 d1 b2 c3 d2 $$R \\div S$$ A a1 在关系R中，A可以取四个值{a1，a2，a3，a4} a1的象集为 {(b1，c2)，(b2，c3)，(b2，c1)} a2的象集为 {(b3，c7)，(b2，c3)} a3的象集为 {(b4，c6)} a4的象集为 {(b6，c6)} S在(B，C)上的投影为: {(b1，c2)，(b2，c1)，(b2，c3) } 只有a1的象集包含了S在(B，C)属性组上的投影, 所以: R ÷ S = { a1 } 2.元组关系演算元组关系演算（Tuple Relational Calculus）是一种用于查询关系型数据库的声明性查询语言。与关系代数一样，它用于从数据库中检索数据，但它的方法更侧重于描述所需的数据，而不是指定如何检索数据。 基本形式：{t|P(t)} 其中 t 是元组变量， P(t) 为元组关系演算公式，简称公式。 它由原子公式和运算符组成。P(t)运算符优先次序：();θ; ∃; ∀; ￢;∧;v 三种形式的原子公式： 1.t ∈ R ：t 是关系 R 中的一个元组 2.s[A] θ c ：元组分量s[A]与常量 c 之间满足比较关系。θ：比较运算符,&lt;, &lt;&#x3D;,&#x3D;, &lt;&gt;,&gt;, &gt;&#x3D; 3.s[A] θ u[B] ：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ 如： {S|(∃s)(Staff(S)^S[position]&#x3D;’Manager’^S[salary]&gt;25000)} 表示列出收入高于25000的所有经理 其中Staff(S)表示S属于表Staff，S[position]表示S的position属性 {ab|R(ab)^R(ba)} 表示(a,b)∈R且(b,a)∈R的元组集合，R为二元关系， 其等价的关系代数表达式为：π1,2 (σ1&#x3D;4∧2-3 (R×R)) 3.事务要么不做，要么全做 脏读：一个事务读了其他事务尚未提交的数据，若该事务回滚了，读取的数据是无效的 不可重复读：一个事务多次读取某一行数据，但结果不一致，因为两次读取之间数据被另一个数据修改了 幻读：事务多次执行一个查询，得到的结果不一致，因为两次查询之间有其他事务新增或删除了行 隔离等级 脏读 不可重复读 幻读 READ UNCOMMITED Y Y Y READ COMMITED N Y Y REPEATABLE READ N N Y SERIALIZABLE N N N **READ UNCOMMITED**：读未提交，最低的隔离等级，一个事务可以读取其他事务尚未提交的数据，行级锁 READ COMMITED：读提交，只能读取已提交的数据，避免了脏读，行级锁 REPEATABLE READ：可重复读，一个事务可以读取其开始之前的数据，且不允许其他事务修改这些数据，行级锁 SERIALIZABLE：串行化，事务彼此之间完全隔离，事务的执行像是串行的，避免了脏读、不可重复读、幻读，表级锁 4.规范化4.1函数依赖完全函数依赖：设X、Y是关系R的两个属性集合，X‘是X的真子集，存在X-&gt;Y，但对每一个X‘-&gt;Y，则称Y完全依赖于X。 即通过AB能得出C，但是AB单独得不出C，称C完全依赖于AB，如（学号，课程）推出分数，但单独用学号、课程推不出分数，则称分数完全依赖于（学号，课程） 部分函数依赖：假如Y函数依赖于X，但同时Y不完全函数依赖于X，则称Y部分函数依赖于X。 即通过AB能得出C，通过A也能得出C，或者通过B也能得出C，那么说C部分依赖于AB，如（学号，课程）能推出姓名，但学号可以直接推出姓名，所以姓名部分依赖于（学号，课程） 传递函数依赖：设X，Y，Z是关系R中互不相同的属性集合，存在X-&gt;Y(Y!-&gt;X)，Y-&gt;Z，则称Z传递函数依赖于X。 即通过A得到B，通过B得到C，但通过C得不到A，那么说C传递依赖于A，如学号推出系名，系名推出系主任，但是系主任推不出学号，那么称系主任传递依赖于学号 超键:能够唯一标识元组的属性集叫做超键。候选键:如果超键不包括多余的属性,那么这个超键就是候选键。主键:用户可以从候选键中选择一个作为主键。外键:如果数据表R1中的某属性集不是R1的主键M而是另一个数据表R2的主键,那么这个属性集就是数据表R1的外键。 4.2第一范式（1NF）数据库表每一行于每一列相交的部分有且只有一个值，即表中每个字段的值不可再分 4.3第二范式（2NF）非主键属性必须完全依赖于主键属性，不能只依赖主键属性的一部分 4.4第三范式（3NF）所有非主键属性不能依赖于其他非主键属性，即不能存在传递依赖关系 5. SQL5.1 CREATE 用于创建新表、视图、索引等数据库对象 12345678910111213141516171819202122#建库CREATE DATABASE test;#建表DROP TABLE IF EXISTS `dept`;CREATE TABLE `dept`( dept_id INT NOT NULL COMMENT &#x27;部门号&#x27;, dept_name VARCHAR(16) NOT NULL COMMENT &#x27;部门名称&#x27;, PRIMARY KEY (dept_id))COMMENT &#x27;部门&#x27;;DROP TABLE IF EXISTS `emp`;CREATE TABLE `emp`( eid INT NOT NULL COMMENT &#x27;员工号&#x27;, name VARCHAR(16) NOT NULL COMMENT &#x27;姓名&#x27;, age INT NOT NULL COMMENT &#x27;年龄&#x27;, time DATE COMMENT &#x27;入职时间&#x27;, incoming INT COMMENT &#x27;收入&#x27;, dept_id INT NOT NULL COMMENT &#x27;部门号&#x27;, FOREIGN KEY (dept_id) REFERENCES dept(dept_id), PRIMARY KEY (eid))COMMENT &#x27;员工表&#x27;; SQL数据类型（MySQL）: 整数类型 TINYINT 1字节整数，范围-128到127（有符号），0到255（无符号） SMALLINT 2字节整数，范围-32,768到32,767（有符号），0到65,535（无符号） MEDIUMINT 3字节整数，范围-8,388,608到8,388,607（有符号），0到16,777,215（无符号） INT（或INTEGER） 4字节整数，通常范围-2,147,483,648到2,147,483,647（有符号），0到4,294,967,295（无符号） BIGINT 8字节整数，范围-9,223,372,036,854,775,808到9,223,372,036,854,775,807（有符号），0到18,446,744,073,709,551,615（无符号） 小数和浮点数类型 DECIMAL 用于精确的十进制数值，例如货币计算。 FLOAT 单精度浮点数 DOUBLE 双精度浮点数，用于存储大范围的浮点数 字符串类型 CHAR 固定长度字符串，最多255个字符 VARCHAR 可变长度字符串，最多65535个字符 TINYTEXT 微型文本，最多255个字符 TEXT 用于一般文本，最多65535个字符 MEDIUMTEXT 用于中等长度文本，最多16,777,215个字符 LONGTEXT 用于大型文本，最多4,294,967,295个字符 日期和时间类型 DATE 用于存储日期，格式'YYYY-MM-DD' TIME 用于存储时间，格式'HH:MM:SS' DATETIME 用于存储日期和时间，格式'YYYY-MM-DD HH:MM:SS' TIMESTAMP 用于存储时间戳，通常表示数据的修改时间 YEAR 用于存储年份（2位或4位表示） 二进制数据类型 BINARY 固定长度的二进制数据类型,最多可以存储255个字节 VARBINARY 可变长度的二进制数据类型，最多可以存储65535个字节 TINYBLOB 用于存储短的二进制数据，最多可以存储255个字节 BLOB 用于存储一般二进制数据，最多可以存储65535个字节 MEDIUMBLOB 用于中等大小的二进制数据，最多可以存储16,777,215个字节 LONGBLOB 用于大型二进制数据，最多可以存储4,294,967,295个字节 布尔类型 BOOLEAN 用于存储布尔值，通常是true或false 5.2 SELECT用于从数据库中检索数据。SELECT语句用于查询表，选择特定的列，并可以根据条件筛选行 12SELECT eid, name, ageFROM emp; 5.3 INSERT用于向数据库表中插入新行的数据。 1INSERT INTO emp(eid, name, age, time, incoming, dept_id) VALUES (1,&#x27;name1&#x27;,18,&#x27;2023-9-14&#x27;,4000,1); 5.4 UPDATE用于更新数据库表中的现有数据 在更新多个列时，只需要使用一条 SET 命令，每个“列&#x3D;值”对之间用逗号分隔（最后一列之后不用逗号） 123UPDATE emp SET emp.incoming = 6000 WHERE emp.eid = 4; 5.5 DELETE从一个表中删除（去掉）数据 1DELETE FROM emp WHERE emp.eid = 8; 5.6 ALTER操纵表结构 123456#添加列ALTER TABLE empADD COLUMN test VARCHAR(16);#删除列ALTER TABLE empDROP COLUMN test; 5.7 WHERE用于指定过滤条件 1234567891011121314151617181920#条件查询SELECT eid, name, ageFROM empWHERE emp.incoming &gt;= 2000 AND emp.dept_id = 3;#范围查询SELECT eid, name, age, incomingFROM empWHERE emp.incoming BETWEEN 2000 AND 5000;#判空查询SELECT eid, name, age, incomingFROM empWHERE dept_id IS NULL;#通配符,能不用就不用，%匹配0到多个字符SELECT eid, name, age, incomingFROM empWHERE name LIKE &#x27;name%&#x27;;#_匹配单个字符SELECT eid, name, age, incomingFROM empWHERE name LIKE &#x27;name_&#x27;; 5.8 GROUP BY进行数据分组，常与聚集函数一同使用 GROUP BY 子句必须出现在WHERE子句之后，ORDER BY子句之前 1234#统计各部门人数SELECT COUNT(*) AS num_person,dept_idFROM empGROUP BY dept_id; 常用聚集函数 AVG() 返回某列平均值 COUNT() 返回某列行数 MAX() 返回某列最大值 MIN() 返回某列最小值 SUM() 返回某列值之和 5.9 HAVING与WHERE类似，WHERE过滤行，HAVING过滤分组 12345SELECT COUNT(*) AS num_person,emp.dept_id,dept.dept_nameFROM emp,deptWHERE emp.dept_id = dept.dept_idGROUP BY dept_idHAVING COUNT(*) &gt;=2 AND dept_id IS NOT NULL; 5.10 ORDER BY用于排序 12345678#正序排序SELECT name,age,incomingFROM empORDER BY incoming;#逆序排序SELECT name,age,incomingFROM empORDER BY incoming DESC; 5.11 AS用于取别名 12SELECT AVG(incoming) AS avg_incomingFROM emp 5.12 JOIN连接 12345678910111213141516171819#笛卡尔积SELECT name,age,incoming,dept_nameFROM emp JOIN dept;#自然连接SELECT name,age,incoming,dept_nameFROM emp NATURAL JOIN dept;#内连接SELECT name,age,incoming,dept_nameFROM emp INNER JOIN dept on emp.dept_id = dept.dept_id;#左连接SELECT name,age,incoming,dept_nameFROM emp LEFT JOIN dept on emp.dept_id = dept.dept_id;#右连接SELECT name,age,incoming,dept_nameFROM emp RIGHT JOIN dept on emp.dept_id = dept.dept_id;#全连接SELECT name,age,incoming,dept_name FROM emp LEFT JOIN dept on emp.dept_id = dept.dept_idUNIONSELECT name,age,incoming,dept_name FROM emp RIGHT JOIN dept on emp.dept_id = dept.dept_id; 5.13 DISTINCT去除重复的值 12SELECT DISTINCT ageFROM emp; 5.14视图虚拟表，和普通表一样使用，数据来自定义视图的使用的原始表，并且是动态生成的 123456#创建视图CREATE VIEW info ASSELECT name,age,incoming,dept_nameFROM emp LEFT JOIN dept on emp.dept_id = dept.dept_id;#删除视图DROP VIEW info; 5.15事务事务隔离级别的设置是在事务开始后执行的，而不是在开启事务时指定的。这是MySQL的标准做法。 12345678910#开启事务BEGIN;#或START TRANSACTION;#设置事务隔离等级，取值有READ UNCOMMITTED,READ COMMITTED,REPEATABLE READ,SERIALIZABLESET TRANSACTION ISOLATION LEVEL REPEATABLE READ;#提交COMMIT;#回滚ROLLBACK； 5.16索引索引：帮助高效获取数据的数据结构 MySQL中常见索引有BTree索引（Myisam普通索引），B+Tree索引（Innodb普通索引），Hash索引（memory存储引擎） 优势： 提高检索效率 降低排序成本 劣势： 占用空间 降低插入删除的效率 5.16.1使用场景推荐使用索引： 主键自动建立唯一索引 频繁作为查询条件的字段应该建立索引 查询中与其他表关联的字段，外键关系建立索引 多字段查询下倾向创建组合索引 查询中排序的字段，建立索引可提高排序速度 查询中统计或分组的字段 不推荐使用索引： 表记录太少 经常增删改的表 WHERE条件里用不到的字段不建立索引 5.16.2索引分类主键索引： 表中的字段设定为主键后会自动建立主键索引 1234#手动创建ALTER TABLE [表名] ADD PRIMARY KEY [字段名]#删除ALTER TABLE [表名] DROP PRIMARY KEY; 唯一索引： 表中的字段创建了唯一约束时会自动建立唯一索引 12345#手动创建ALTER TABLE [表名] ADD UNIQUE INDEX [索引名]([字段名]);CREATE UNIQUE INDEX [索引名] ON [表名]([字段名]);#删除DROP INDEX [索引名] ON Scores; 单值索引： 即一个索引只包含单个列，一个表可以有多个单值索引 12345#手动创建ALTER TABLE [表名] ADD INDEX [索引名]([字段名]);CREATE INDEX [索引名] ON [表名]([字段名]);#删除DROP INDEX [索引名] ON Scores; 复合索引： 即一个索引包含多个字段 12345#手动创建ALTER TABLE [表名] ADD INDEX [索引名]([字段1],[字段2]);CREATE INDEX [索引名] ON [表名]([字段1],[字段2]);#删除DROP INDEX [索引名] ON Scores; 5.16.3索引失效 索引了多列，查询要从索引的最左前列开始且不跳过索引中的列，会导致索引失效 不在索引列上做任何计算、函数操作，会导致索引失效 范围条件右边的列索引失效，如where age &gt;23 and score &#x3D; 100,score索引失效 MySQL在使用不等于时无法使用索引 IS NULL可以使用索引，IS NOT NULL无法使用索引 LIKE 以通配符开头会使索引失效 OR 前后只要存在非索引的列 5.17 EXPLAINid：用于区分不同查询操作，值越大的查询优先级越高，相同时执行顺序由上至下 table： 表示这一行的数据是如何获取的。可能是一个表名，也可能是一个临时表或子查询。 select_type： SIMPLE：简单查询，不包含子查询或联接 PRIMARY：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归查询这些子查询，把结果放在临时表里 SUBQUERY：在SELECT或WHERE列表中包含了子查询 type： system：只有一行数据（系统表） const：通过索引一次就找到 eq_ref：使用唯一索引查找 ref：非唯一索引查找 range：范围查找，例如使用BETWEEN或IN index：使用索引进行全表扫描 all：全表扫描 possible_keys： 显示可能用于查询的索引列表 key：表示实际使用的索引。如果没有使用索引，该值为NULL key_len： 表示索引中使用的字节数 ref：显示索引哪一列被使用了,常数表示这一列等于某个常数 rows： 表示MySQL估计需要检查的行数。这是一个估算值，不一定等于实际的行数 filtered： 表示行的过滤程度，通常是一个百分比值。它表示在表中找到的行数占估计的行数的百分比 Extra： 包含其他的执行信息，如使用了临时表、使用了文件排序等","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]},{"title":"Python学习笔记","slug":"python-note","date":"2021-10-05T15:22:41.000Z","updated":"2024-05-14T14:24:58.085Z","comments":false,"path":"python-note/","permalink":"http://example.com/python-note/","excerpt":"","text":"1.安装1.1windows下载python(压缩包)：https://www.python.org/downloads/windows/ 下载pip:https://bootstrap.pypa.io/get-pip.py 解压后进入python目录，执行python get-pip.py 将python目录和其目录下的Scripts文件夹加入环境变量 1234#pip换源pip config set global.index-url https://mirrors.aliyun.com/pypi/simple#pip修改下载路径pip config set global.download-cache E:\\Python\\python-3.10.7-embed-amd64\\Scripts\\pip_cache 将文件python310._pth中import site前的#去掉 1.2ubuntu自带python，apt下载pip 1sudo apt install python3-pip 2.语法2.1单行注释1234#!/usr/bin/python3 # 第一个注释print (&quot;Hello, Python!&quot;) # 第二个注释 2.2多行注释单引号和双引号在python作用相同 12345678910&#x27;&#x27;&#x27;多行注释&#x27;&#x27;&#x27;&quot;&quot;&quot;&quot;&quot;&quot;def print_hi(name): print(f&#x27;Hi, &#123;name&#125;&#x27;) 2.3行与缩进建议用空格而不是tab 2.4常见数据类型2.4.1 Number包括int, float,bool,complex 可以用type()和isinstance()来判断数据类型，type()不会认为子类是一种父类类型，isinstance()会认为子类是一种父类类型。 12345a = Trueprint(type(int()) == type(a))print(type(bool()) == type(a))print(isinstance(int(), type(a)))print(isinstance(bool(), type(a))) 2.4.2 String使用反斜杠 \\ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串 12print(r&#x27;a\\nbc&#x27;)print(&#x27;a\\nbc&#x27;) Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始 Python中的字符串不能改变 123456789Str = &#x27;123456&#x27;print(Str) # 输出字符串print(Str[0:-1]) # 输出第一个到倒数第二个的所有字符print(Str[0]) # 输出字符串第一个字符print(Str[2:5]) # 输出从第三个开始到第五个的字符print(Str[2:]) # 输出从第三个开始的后的所有字符print(Str * 2) # 输出字符串两次，也可以写成 print (2 * str)print(Str + &quot;TEST&quot;) # 连接字符串 2.4.3 List列表截取的语法格式为 变量[头下标:尾下标] 123456789list = [ &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2 ]tinylist = [123, &#x27;runoob&#x27;]print (list) # 输出完整列表print (list[0]) # 输出列表第一个元素print (list[1:3]) # 从第二个开始输出到第三个元素print (list[2:]) # 输出从第三个元素开始的所有元素print (tinylist * 2) # 输出两次列表print (list + tinylist) # 连接列表 列表截取可以接收第三个参数，参数作用是截取的步长,如果第三个参数为负数表示逆向读取 1234Str = &#x27;wo cao ni ma&#x27;words = Str.split(&quot; &quot;)print(words)print(words[-1::-1]) 2.4.4 Tuple元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 1234tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号print(tup1)print(tup2) 2.4.4 Set可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 **{ }**，因为 { } 是用来创建一个空字典。 12345678sites = &#123;&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Facebook&#x27;, &#x27;Zhihu&#x27;, &#x27;Baidu&#x27;&#125;sites2 = set([&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;1213&#x27;])print(sites)print(sites2)print(sites - sites2) # 差集print(sites | sites2) # 并集print(sites &amp; sites2) # 交集print(sites ^ sites2) # 补集的并集 2.4.5 Dictionary它是一个无序的 键(key) : 值(value) 的集合,类似map 1234567dict = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;dict[&#x27;one&#x27;] = 1print(dict.get(&#x27;one&#x27;))print(dict.keys())print(dict.values())dict.pop(&#x27;one&#x27;)print(dict) 2.5运算符and 与 or 或 not 非 in 如果在指定的序列中找到值返回 True，否则返回 False。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 is 判断两个标识符是不是引用自一个对象 is not 断两个标识符是不是引用自不同对象 2.6迭代器与生成器1234list = [1, 2, 3, 4]it = iter(list)# 创建迭代器对象for num in it: print(num, end=&quot; &quot;) 使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作 1234567891011121314151617181920import sysdef fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1# f 是一个迭代器，由生成器返回生成# 通过next(f)或f.next()调用，遇到yield时停止,没有yield时抛出异常f = fibonacci(10)while True: try: print(next(f), end=&quot; &quot;) except StopIteration: sys.exit() 2.7不定长参数加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数 1234567def printinfo( arg1, *vartuple ): print (&quot;输出: &quot;) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 加了两个星号 ** 的参数会以字典的形式导入。 参数中星号 ***** 可以单独出现,单独出现星号 ***** 后的参数必须用关键字传入 1234567def printinfo( arg1, **vardict ): print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 2.8闭包闭包就是外部函数中定义一个内部函数,内部函数引用外部函数中的变量,外部函数的返回值是内部函数 12345678def power(exp): def exp_of(base): return base ** exp return exp_ofif __name__ == &#x27;__main__&#x27;: p = power(2) print(p(3)) 外部函数的变量会被保存，因此可配合nonlocal关键词实现一定的记忆功能 123456789101112131415def outer(): x = 0 y = 0 def inner(x1,y1): nonlocal x,y x += x1 y += y1 print(f&quot;x=&#123;x&#125;,y=&#123;y&#125;\\n&quot;) return innerif __name__ == &#x27;__main__&#x27;: o = outer() o(1,1) o(2,2) o(-1,-1) 2.9装饰器通过闭包实现 123456789101112131415161718192021import timedef time_master(func): def call_func(): start = time.time() func() stop = time.time() print(&quot;调用函数花费了%.10f毫秒&quot; % (stop - start)) return call_func@time_masterdef test(): count = 0 while count&lt;10: print(&quot;我是test函数&quot;) count+=1#相当于myfunc = time_master(myfunc)#myfunc()if __name__ == &#x27;__main__&#x27;: test() 2.10 lambda表达式匿名函数 1234567#语法 lambda 参数列表:返回值add = lambda a,b:a+bprint(add(1,2))#等价于def add(a,b): return a+bprint(add(1,2)) 2.11异常12345678910111213141516171819202122#捕获异常try: print(1/0)except: print(&quot;error&quot;)else: print(&quot;no error&quot;)finally: print(&quot;over&quot;)#捕获并提取异常try: print(1/0)except ZeroDivisionError as err: print(err)#捕获多个异常try: print(1/1) print(520+&quot;1234&quot;)except (ZeroDivisionError,TypeError) as err: print(err)#抛出异常raise ValueError(&quot;value error&quot;) 2.12模块和包import 模块名称 from 模块名称 import 对象名称 import 模块名称 as 别名 2.13面向对象12345678910111213141516171819202122232425262728293031323334353637383940#定义类class People: #公有属性 name=&quot;&quot; age = 0 #私有属性 __weight = 0 #构造函数 def __init__(self,name,age,weight): self.name = name self.age = age self.__weight = weight def speak(self): print(f&quot;我是people,name=&#123;self.name&#125;,age=&#123;self.age&#125;&quot;)class Boy: hobby=&quot;&quot; def __init__(self,hobby): self.hobby = hobby#单继承class Student(People): id=&quot;&quot; def __init__(self,name,age,weight,id): People.__init__(self,name,age,weight) self.id = id def speak(self): print(f&quot;我是student,name=&#123;self.name&#125;,age=&#123;self.age&#125;,id=&#123;self.id&#125;&quot;)#多继承class Example(People,Boy): a=0 def __init__(self,name,age,weight,hobby): People.__init__(self,name, age, weight) Boy.__init__(self,hobby) self.a = 123 def speak(self): print(f&quot;我是example,name=&#123;self.name&#125;,age=&#123;self.age&#125;,hobby=&#123;self.hobby&#125;&quot;)if __name__ == &#x27;__main__&#x27;: student = Student(&quot;student&quot;,10,100,&quot;2019302654&quot;) student.speak() example = Example(&quot;example&quot;,10,100,&quot;football&quot;) example.speak()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[]},{"title":"Spring学习笔记","slug":"Spring-note","date":"2021-01-05T06:22:41.000Z","updated":"2024-05-14T14:59:48.578Z","comments":false,"path":"Spring-note/","permalink":"http://example.com/Spring-note/","excerpt":"","text":"1.IDEA控制台输出乱码在bin文件夹下的idea64.exe.vmoptions文件后追加-Dfile.encoding&#x3D;UTF-8 2.IOC2.1底层原理xml解析,工厂模式，反射机制 2.1.1bean作用域bean默认为单实例对象，可通过scope进行设置，scope有以下几个值 (1)singleton，表示是单实例对象，加载xml文件时创建对象实例 (2)prototype，表示是多实例对象，获取时创建对象实例 (3)request (4)session 2.1.2bean生命周期(1)创建bean实例 (2)为bean的属性设置值和对其它bean的引用 (3)调用bean的初始化方法(需要进行配置初始化的方法) (4)bean可以使用了 (5)当容器关闭时，调用bean的销毁方法(需要进行配置销毁的方法) 2.2xmlpom.xml 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2.1基本属性的注入beans 12345678package org.study.spring.bean;public class Student &#123; private int id; private String name; private int age; /*getter,setter,constructor,toString略*/&#125; xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置User对象创建--&gt; &lt;bean id=&quot;student1&quot; class=&quot;org.study.spring.bean.Student&quot;&gt;&lt;/bean&gt; &lt;!--set方法注入属性--&gt; &lt;bean id=&quot;student2&quot; class=&quot;org.study.spring.bean.Student&quot;&gt; &lt;!--使用Property来进行属性注入--&gt; &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;Micah&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--有参构造方法注入属性--&gt; &lt;bean id=&quot;student3&quot; class=&quot;org.study.spring.bean.Student&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;lichang&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- p名称空间注入 --&gt; &lt;bean id=&quot;student4&quot; class=&quot;org.study.spring.bean.Student&quot; p:id=&quot;4&quot; p:name=&quot;cmf&quot;/&gt;&lt;/beans&gt; Main 1234567891011public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); Student studen1 = context.getBean(&quot;student1&quot;,Student.class); Student studen2 = context.getBean(&quot;student2&quot;,Student.class); Student studen3 = context.getBean(&quot;student3&quot;,Student.class); Student studen4 = context.getBean(&quot;student4&quot;,Student.class); System.out.println(studen1.toString()); System.out.println(studen2.toString()); System.out.println(studen3.toString()); System.out.println(studen4.toString());&#125; 2.2.2对象属性注入beans 12345678package org.study.spring.bean;public class Book &#123; private String IBSN; private double price; private User author;&#125; 1234567package org.study.spring.bean;public class User &#123; private int id; private String name; private int age;&#125; xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;book1&quot; class=&quot;org.study.spring.bean.Book&quot;&gt; &lt;!-- 普通属性 --&gt; &lt;property name=&quot;IBSN&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;18.8&quot;&gt;&lt;/property&gt; &lt;!-- 注入对象属性 ref为要注入对象的id --&gt; &lt;property name=&quot;author&quot; ref=&quot;user1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;book2&quot; class=&quot;org.study.spring.bean.Book&quot;&gt; &lt;!-- 普通属性 --&gt; &lt;property name=&quot;IBSN&quot; value=&quot;002&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;18.8&quot;&gt;&lt;/property&gt; &lt;!-- 对象属性 --&gt; &lt;property name=&quot;author&quot;&gt; &lt;bean id=&quot;user2&quot; class=&quot;org.study.spring.bean.User&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;002&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;user002&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;user1&quot; class=&quot;org.study.spring.bean.User&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;user001&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Main 1234567public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book1 = context.getBean(&quot;book1&quot;, Book.class); Book book2 = context.getBean(&quot;book2&quot;, Book.class); System.out.println(book1.toString()); System.out.println(book2.toString());&#125; 2.2.3集合类型注入beans 12345678910111213package org.study.spring.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Demo &#123; private String[] array; private List&lt;String&gt; list; private Map&lt;String,String&gt; map; private Set&lt;String&gt; set;&#125; xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 集合类型注入 --&gt; &lt;bean id=&quot;demo1&quot; class=&quot;org.study.spring.bean.Demo&quot;&gt; &lt;!-- 数组类型注入 --&gt; &lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;!-- 若要注入对象，格式如下: &lt;ref bean=“id”&gt;&lt;/ref&gt; --&gt; &lt;value&gt;abc&lt;/value&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;efg&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- list类型注入 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;awf&lt;/value&gt; &lt;value&gt;jzn&lt;/value&gt; &lt;value&gt;135&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- map类型注入 --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;!-- 若要注入对象，格式如下: &lt;entry key-ref=&quot;id&quot; value-ref=&quot;id&quot;&gt;&lt;/entry&gt; --&gt; &lt;entry key=&quot;a&quot; value=&quot;12&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;b&quot; value=&quot;34&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;c&quot; value=&quot;56&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- set类型注入 --&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;456&lt;/value&gt; &lt;value&gt;abc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Main 12345public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Demo demo1 = context.getBean(&quot;demo1&quot;, Demo.class); System.out.println(demo1.toString());&#125; 2.2.4自动装配beans 12345678package org.study.spring.bean;public class Book &#123; private String IBSN; private double price; private User author;&#125; 1234567package org.study.spring.bean;public class User &#123; private int id; private String name; private int age;&#125; xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;book1&quot; class=&quot;org.study.spring.bean.Book&quot; autowire=&quot;byName&quot;&gt; &lt;!-- 普通属性 --&gt; &lt;property name=&quot;IBSN&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;18.8&quot;&gt;&lt;/property&gt; &lt;!-- byName方法注入要求注入bean的id与被注入的变量名相同 --&gt; &lt;/bean&gt; &lt;bean id=&quot;book2&quot; class=&quot;org.study.spring.bean.Book&quot; autowire=&quot;byType&quot;&gt; &lt;!-- 普通属性 --&gt; &lt;property name=&quot;IBSN&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;18.8&quot;&gt;&lt;/property&gt; &lt;!-- byType方法注入要求注入bean类型的实例只有一个，否则会保存 --&gt; &lt;/bean&gt; &lt;bean id=&quot;author&quot; class=&quot;org.study.spring.bean.User&quot;&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;user001&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Main 1234567public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book1 = context.getBean(&quot;book1&quot;, Book.class); Book book2 = context.getBean(&quot;book2&quot;, Book.class); System.out.println(book1.toString()); System.out.println(book2.toString());&#125; 2.2.5引入外部文件beans 1234567package org.study.spring.bean;public class Student &#123; private int id; private String name; private int age;&#125; xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:data.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;bean id=&quot;student1&quot; class=&quot;org.study.spring.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;$&#123;student.id&#125;&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;student.name&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;student.age&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Main 12345public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean5.xml&quot;); Student student1 = context.getBean(&quot;student1&quot;,Student.class); System.out.println(student1.toString());&#125; data.properties 123student.id=2student.age=18student.name=Micah 2.3注解pom.xml 12345678910111213141516171819202122232425262728&lt;dependencies&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 2.3.1创建对象的注解(1)@Component (2)@Service (3)@Controller (4)@Repository 这四个注解的功能是一样的，都可以用来创建bean实例 bean 12345678910111213package org.study.spring.service;import org.springframework.stereotype.Component;//注解中的value可以不写，相当于bean中的id//不写value，其id默认为类名将首字母小写@Component(value = &quot;userService&quot;)public class UserService &#123; public void print()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启组件扫描,多个包可用逗号隔开 --&gt; &lt;context:component-scan base-package=&quot;org.study.spring&quot;&gt;&lt;/beans&gt; 包扫描的细化 12345678&lt;!-- 设置扫描的内容 --&gt;&lt;context:component-scan base-package=&quot;org.study.spring&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!-- 设置不扫描的内容 --&gt;&lt;context:component-scan base-package=&quot;org.study.spring&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt;&lt;/context:component-scan&gt;&lt;/context:component-scan&gt; Main 12345public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean6.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;,UserService.class); userService.print();&#125; 2.3.2注入属性的注解(1)@Autowired 根据属性类型进行自动装配(不需要set方法) (2)@Qualifier 根据属性名称进行注入 和@Autowire搭配使用 12@Autowired@Qualifier(value = &quot;id&quot;) (3)@Resource 可以根据类型注入，也可以根据名称注入 12@Resource //根据类型注入@Resource( name = &quot;id&quot;) //根据名称注入 (4)@Value 注入普通类型 1@Value( value = &quot;abc&quot;) 2.3.3完全注解开发增加配置类，代替xml SpringConfig 12345678910111213141516171819package org.study.spring.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.study.spring.bean.Student;@Configuration@ComponentScan(basePackages = &#123;&quot;org.study.spring&quot;&#125;)public class SpringConfig &#123; /** * 注解类中引用其它bean可直接在函数参数中写相应类型的变量 * 多个同类型的变量使用@Qualifier选择注入 */ @Bean(name=&quot;student1&quot;) public Student getStudent()&#123; return new Student(1,&quot;student1&quot;,20); &#125;&#125; Main 1234567public static void main(String[] args)&#123; ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;,UserService.class); userService.print(); Student student1 = context.getBean(&quot;student1&quot;,Student.class); System.out.println(student1.toString());&#125; 2.3.4使用注解获取properties文件的值可以使用Environment或@Value获取，但版本过低的spring中用@Value获取会失败，这里使用的spring版本号为5.2.6.RELEASE 1234567891011121314151617@Configuration@ComponentScan(basePackages = &#123;&quot;org.study.spring&quot;&#125;)@PropertySource(value = &#123;&quot;classpath:data.properties&quot;&#125;)public class SpringConfig &#123; @Autowired private Environment environment; @Value(&quot;$&#123;student.name&#125;&quot;) private String name; @Bean(name=&quot;student1&quot;) public Student getStudent()&#123; System.out.println(this.name); return new Student(Integer.valueOf(environment.getProperty(&quot;student.id&quot;)),environment.getProperty(&quot;student.name&quot;),Integer.valueOf(environment.getProperty(&quot;student.age&quot;))); &#125;&#125; 3.AOP3.1JDK动态代理接口 1234567public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; 接口实现 1234567891011public class UserDaoImpl implements UserDao&#123; @Override public int add(int a, int b) &#123; return a+b; &#125; @Override public String update(String id) &#123; return id; &#125;&#125; 代理 123456789101112131415161718public class JDKProxy &#123; public static void main(String[] args)&#123; Class[] interfaces = &#123;UserDao.class&#125;; UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;方法执行之前...&quot;+method.getName()+&quot;,传递的参数:&quot;+ Arrays.toString(args)); //被增强方法的执行 Object res = method.invoke(userDao,args); System.out.println(&quot;方法执行之前...&quot;+userDao); return res; &#125; &#125;); dao.add(1,2); &#125;&#125; 3.2AOP术语(1)连接点 类里可以被增强的方法 (2)切入点 实际被真正增强的方法 (3)增强(通知) 实际增强的逻辑部分，前置通知，后置通知，环绕通知，异常通知，最终通知 (4)切面 把通知应用到切入点的过程 3.3AspectJSpring框架一般是基于AspectJ实现AOP 切入点表达式:execution( [权限修饰符] [返回类型] [全类名] [方法名称] [参数列表]) 如：execution(* org.study.spring.aop.UserDao.add(…))，对add方法进行增强 pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt; 代理类 123456789@Component@Aspectpublic class UserProxy &#123; @Before(value = &quot;execution(* org.study.spring.aop.User.function1(..))&quot;) public void before()&#123; System.out.println(&quot;before&quot;); &#125;&#125; 被增强的类 123456@Componentpublic class User &#123; public void function1() &#123; System.out.println(&quot;fuction1...&quot;); &#125;&#125; xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启组件扫描,多个包可用逗号隔开 --&gt; &lt;context:component-scan base-package=&quot;org.study.spring.aop&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 开启AspectJ生成代理对象 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!-- 若要增加的类实现了接口，则需加上属性proxy-target-class=&quot;true&quot; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt; --&gt;&lt;/beans&gt; Main 12345public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean7.xml&quot;); User user = context.getBean(&quot;user&quot;,User.class); user.function1();&#125; 4.Spring事务xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 开启组件扫描,多个包可用逗号隔开 --&gt; &lt;context:component-scan base-package=&quot;org.study.spring.aop&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 开启AspectJ生成代理对象 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;!-- 若要增加的类实现了接口，则需加上属性proxy-target-class=&quot;true&quot; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;&lt;/aop:aspectj-autoproxy&gt; --&gt; &lt;!-- 创建数据源 --&gt; &lt;bean id=&quot;datasource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/study?serverTimezone=Asia/Shanghai&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建jdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务注解,等同于@EnableTransactionManagement --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; @Transactional：使用在方法或者类的上面。 事务传播行为,参数为propagation (1)REQUIRED：如果有事务在运行，当前的方法就在这个事务内运行，否则开启新事物并在自己的事务内运行 (2)REQUIRED_NEW：当前的方法必须启动新事务，并在自己的事务内运行，如果有事务正在运行，应该将它挂起 (3)SUPPORTS：如果有事务在运行，当前的方法就在这个事务内运行，否则它不可以运行在事务中 隔离等级，参数为isolation (1)TransactionDefnion.ISOLATION_DEFAULT 这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 (2)Transactionboehnlion. ISOLATION_READ_UNCOMMITTED 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据，该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 (3)TransactionDefinition.ISOLATION_READ_COMMITTED 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 (4)TransactionDefinition.ISOLATION_REPEATABLE_READ 该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 (5)TransactionDefinition.ISOLATION_SERIALIZABLE 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 5.SpringMVC5.1概念(1)M，即model，指工程中的javaBean (2)V，即view，指工程中的html或jsp (3)C，即Controller，指工程中的servlet，作用是接收请求和响应浏览器 IDEA的maven项目中可以右键项目，选择open module settings(F4)进行配置， 5.2web.xml配置pom.xml 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--post乱码过滤器--&gt; &lt;!-- 配置springMVC编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 过滤所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置SpringMVC前端控制器，对浏览器发出的请求进行统一处理 --&gt; &lt;servlet&gt; &lt;!-- servlet-name要与servlet-mapping保持一致 --&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 使用java类代替xml配置 --&gt;&lt;!-- &lt;init-param&gt;--&gt;&lt;!-- &lt;param-name&gt;contextClass&lt;/param-name&gt;--&gt;&lt;!-- &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;--&gt;&lt;!-- &lt;/init-param&gt;--&gt;&lt;!-- &lt;init-param&gt;--&gt;&lt;!-- &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;&lt;!-- &lt;param-value&gt;org.springMVC.study.config.WebConfig&lt;/param-value&gt;--&gt;&lt;!-- &lt;/init-param&gt;--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 多个值以;隔开 --&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 将DispatcherServlet初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- /匹配的请求可以是/login,.html,.css方式的请求路径， 但不能是.jsp --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; spring-mvc.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- spring mvc 的注解驱动--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 扫描组件 --&gt; &lt;context:component-scan base-package=&quot;org.springMVC.study&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 进行jsp解析--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--配置前缀和后缀，也可以不指定 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 静态资源映射 --&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/resource/css/&quot;&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/resource/js/&quot;&gt;&lt;/mvc:resources&gt;&lt;/beans&gt; 6.jdk生成自签证书命令：keytool -genkey -alias testhttps -keyalg RSA -keysize 2048 -validity 36500 -keystore “D:&#x2F;tmp&#x2F;ssl&#x2F;testhttps.keystore” 命令解释:• -genkey 表示要创建一个新的密钥。 • -alias 表示 keystore 的别名。 • -keyalg 表示使用的加密算法是 RSA。 • -keysize 表示密钥的长度。 • -keystore 表示生成的密钥存放位直。 • -validity 表示密钥的有效时间，单位为天。 12345678910server: servlet: context-path: /test ssl: key-store: classpath:testhttps.keystore key-password: abcdefg key-store-password: abcdefg key-store-type: JKS key-alias: testhttps enabled: true","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[]}],"categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"Netty","slug":"Netty","permalink":"http://example.com/categories/Netty/"},{"name":"Matlab","slug":"Matlab","permalink":"http://example.com/categories/Matlab/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://example.com/categories/Kubernetes/"},{"name":"Go","slug":"Go","permalink":"http://example.com/categories/Go/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"消息队列","slug":"消息队列","permalink":"http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[]}